<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>MAV&#39;RIC: /home/julien/Desktop/tmp/maveric/Code/Maveric_myCopter/src/asf/avr32/drivers/usbc/usbc_device.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAV&#39;RIC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6aa15536841142c7fd9884591ab4637c.html">Code</a></li><li class="navelem"><a class="el" href="dir_e7508e30365965c9dcbce91a45b45d1d.html">Maveric_myCopter</a></li><li class="navelem"><a class="el" href="dir_1e7c005b64bc1bab0cc223285642e49e.html">src</a></li><li class="navelem"><a class="el" href="dir_3fde7950560bc9c25d0c9126d08f6f23.html">asf</a></li><li class="navelem"><a class="el" href="dir_282c6a066e740cacc0849dedafd651a0.html">avr32</a></li><li class="navelem"><a class="el" href="dir_343d0262a8b14353a086ac8fa2a8c319.html">drivers</a></li><li class="navelem"><a class="el" href="dir_20ff8b57afc61a8c73debee6e48d4d25.html">usbc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">usbc_device.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>USBC Device Driver header file.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;compiler.h&quot;</code><br />
<code>#include &quot;<a class="el" href="preprocessor_8h_source.html">preprocessor.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for usbc_device.h:</div>
<div class="dyncontent">
<div class="center"><img src="usbc__device_8h__incl.png" border="0" usemap="#_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8h" alt=""/></div>
<map name="_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8h" id="_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8h">
<area shape="rect" id="node3" href="preprocessor_8h.html" title="Preprocessor utils. " alt="" coords="131,124,239,151"/><area shape="rect" id="node4" href="tpaste_8h.html" title="Preprocessor token pasting utils. " alt="" coords="5,199,75,225"/><area shape="rect" id="node5" href="stringz_8h.html" title="Preprocessor stringizing utils. " alt="" coords="99,199,171,225"/><area shape="rect" id="node6" href="mrepeat_8h.html" title="Preprocessor macro repeating utils. " alt="" coords="195,199,275,225"/></map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="usbc__device_8h__dep__incl.png" border="0" usemap="#_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8hdep" alt=""/></div>
<map name="_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8hdep" id="_2home_2julien_2Desktop_2tmp_2maveric_2Code_2Maveric__myCopter_2src_2asf_2avr32_2drivers_2usbc_2usbc__device_8hdep">
<area shape="rect" id="node2" href="usbc__device_8c.html" title="USB Device driver Compliance with common driver UDD. " alt="" coords="5,124,191,195"/><area shape="rect" id="node3" href="asf_8h.html" title="Autogenerated API include file for the Atmel Software Framework (ASF) " alt="" coords="215,131,397,187"/><area shape="rect" id="node4" href="generator_8h.html" title="/home/julien/Desktop\l/tmp/maveric/Code/Library\l/util/generator.h" alt="" coords="218,243,394,299"/><area shape="rect" id="node5" href="generator_8c.html" title="/home/julien/Desktop\l/tmp/maveric/Code/Library\l/util/generator.c" alt="" coords="218,347,394,403"/></map>
</div>
</div>
<p><a href="usbc__device_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__sizes__t.html">avr32_usbc_udesc_sizes_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__bk__ctrl__stat__t.html">avr32_usbc_udesc_bk_ctrl_stat_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavr32__usbc__udesc__ep__ctrl__stat__t.html">avr32_usbc_udesc_ep_ctrl_stat_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structusb__desc__table__t.html">usb_desc_table_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device IP properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros give access to IP properties </p>
</div></td></tr>
<tr class="memitem:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f3fc518ef0e369cc01a7bf7c6516844"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f3fc518ef0e369cc01a7bf7c6516844">UDD_get_endpoint_max_nbr</a>()&#160;&#160;&#160;(((Rd_bitfield(AVR32_USBC_ufeatures, AVR32_USBC_UFEATURES_EPT_NBR_MAX_MASK) - 1) &amp; ((1 &lt;&lt; AVR32_USBC_UFEATURES_EPT_NBR_MAX_SIZE) - 1)) + 1)</td></tr>
<tr class="memdesc:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal number of endpoints. <br /></td></tr>
<tr class="separator:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device speeds management</div></td></tr>
<tr class="memitem:gaf272a0d4210ee260d0a267bba460fb0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf272a0d4210ee260d0a267bba460fb0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf272a0d4210ee260d0a267bba460fb0c">udd_low_speed_enable</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="memdesc:gaf272a0d4210ee260d0a267bba460fb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable device low-speed mode. <br /></td></tr>
<tr class="separator:gaf272a0d4210ee260d0a267bba460fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6471bbaea371bb9bb2654333236c9f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6471bbaea371bb9bb2654333236c9f29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_low_speed_disable</b>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="separator:ga6471bbaea371bb9bb2654333236c9f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedea021600d07a71a1672b393c550c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaedea021600d07a71a1672b393c550c39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaedea021600d07a71a1672b393c550c39">Is_udd_low_speed_enable</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="memdesc:gaedea021600d07a71a1672b393c550c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if device low-speed mode is forced. <br /></td></tr>
<tr class="separator:gaedea021600d07a71a1672b393c550c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae014bb3adcdf212fd61196307be88802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae014bb3adcdf212fd61196307be88802"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_high_speed_enable</b>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:gae014bb3adcdf212fd61196307be88802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7adf42a2ec72e7f2429a9b02799333af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7adf42a2ec72e7f2429a9b02799333af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_high_speed_disable</b>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:ga7adf42a2ec72e7f2429a9b02799333af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977c78f164f32fa910802518aab7b0ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga977c78f164f32fa910802518aab7b0ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_full_speed_mode</b>()&#160;&#160;&#160;true</td></tr>
<tr class="separator:ga977c78f164f32fa910802518aab7b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device vbus management</div></td></tr>
<tr class="memitem:gaf80c5f873a9d926ab3324b6a91dfd872"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf80c5f873a9d926ab3324b6a91dfd872"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_enable_vbus_interrupt</b>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gaf80c5f873a9d926ab3324b6a91dfd872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11887e29c08ad9cc6d67e3e6b4f9e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad11887e29c08ad9cc6d67e3e6b4f9e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_vbus_interrupt</b>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gad11887e29c08ad9cc6d67e3e6b4f9e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8ac44b2b2082c1797e873e120867c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed8ac44b2b2082c1797e873e120867c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gaed8ac44b2b2082c1797e873e120867c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bc6d84d73e1ecccae3318d4098c41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10bc6d84d73e1ecccae3318d4098c41a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_high</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUS_MASK))</td></tr>
<tr class="separator:ga10bc6d84d73e1ecccae3318d4098c41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f962d911e1863d143614d1ee01df89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f962d911e1863d143614d1ee01df89a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_low</b>()&#160;&#160;&#160;(!Is_udd_vbus_high())</td></tr>
<tr class="separator:ga6f962d911e1863d143614d1ee01df89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6886b5956566ddb81744bbcfb27c08d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6886b5956566ddb81744bbcfb27c08d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_vbus_transition</b>()&#160;&#160;&#160;(AVR32_USBC.usbstaclr = AVR32_USBC_USBSTACLR_VBUSTIC_MASK)</td></tr>
<tr class="separator:gac6886b5956566ddb81744bbcfb27c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8761342ea2dc32e0f0252508b1f7c47a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8761342ea2dc32e0f0252508b1f7c47a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_vbus_transition</b>()&#160;&#160;&#160;(AVR32_USBC.usbstaset = AVR32_USBC_USBSTASET_VBUSTIS_MASK)</td></tr>
<tr class="separator:ga8761342ea2dc32e0f0252508b1f7c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6dd005e6fef2574f054b8fe5e8d008"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb6dd005e6fef2574f054b8fe5e8d008"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_transition</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUSTI_MASK))</td></tr>
<tr class="separator:gafb6dd005e6fef2574f054b8fe5e8d008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device attach control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device attach. </p>
</div></td></tr>
<tr class="memitem:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1863dacf593fb3c1b5f275b48f1e529a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1863dacf593fb3c1b5f275b48f1e529a">udd_detach_device</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="mdescLeft">&#160;</td><td class="mdescRight">detaches from USB bus <br /></td></tr>
<tr class="separator:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55686d13fc7b23f4945f527f0dd15906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55686d13fc7b23f4945f527f0dd15906"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga55686d13fc7b23f4945f527f0dd15906">udd_attach_device</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:ga55686d13fc7b23f4945f527f0dd15906"><td class="mdescLeft">&#160;</td><td class="mdescRight">attaches to USB bus <br /></td></tr>
<tr class="separator:ga55686d13fc7b23f4945f527f0dd15906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c45e04066c136079dd296c2e28bb62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8c45e04066c136079dd296c2e28bb62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf8c45e04066c136079dd296c2e28bb62">Is_udd_detached</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:gaf8c45e04066c136079dd296c2e28bb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if the device is detached <br /></td></tr>
<tr class="separator:gaf8c45e04066c136079dd296c2e28bb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device bus events control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device bus events. </p>
</div></td></tr>
<tr class="memitem:gacc4b62140d09930dd38b10f766d30517"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc4b62140d09930dd38b10f766d30517">udd_initiate_remote_wake_up</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr class="separator:gacc4b62140d09930dd38b10f766d30517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3dab5078ad3286ac92d7b3a8cf8933a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3dab5078ad3286ac92d7b3a8cf8933a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_pending_remote_wake_up</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr class="separator:gaf3dab5078ad3286ac92d7b3a8cf8933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga0f538482266ca447cbfcfb9a5eb2bd64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0f538482266ca447cbfcfb9a5eb2bd64">udd_enable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td></tr>
<tr class="separator:ga0f538482266ca447cbfcfb9a5eb2bd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53f9dce1280a2b17218090cde573368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad53f9dce1280a2b17218090cde573368"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_remote_wake_up_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_UPRSMEC_MASK)</td></tr>
<tr class="separator:gad53f9dce1280a2b17218090cde573368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4c5935ae7ae26e8edf63a27d3d30d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a4c5935ae7ae26e8edf63a27d3d30d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_remote_wake_up_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_UPRSME_MASK))</td></tr>
<tr class="separator:ga2a4c5935ae7ae26e8edf63a27d3d30d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c4b005d3194988c8969ea622eed23d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39c4b005d3194988c8969ea622eed23d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_remote_wake_up_start</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_UPRSMC_MASK)</td></tr>
<tr class="separator:ga39c4b005d3194988c8969ea622eed23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9d45e299d7a26b65bf8a98c8e27546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e9d45e299d7a26b65bf8a98c8e27546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_remote_wake_up_start</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_UPRSMS_MASK)</td></tr>
<tr class="separator:ga8e9d45e299d7a26b65bf8a98c8e27546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe73866ea62b418fe69fa061ef6edd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacfe73866ea62b418fe69fa061ef6edd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_remote_wake_up_start</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_UPRSM_MASK))</td></tr>
<tr class="separator:gacfe73866ea62b418fe69fa061ef6edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gad7f806ed3fbecb776acc5dcedcf81f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad7f806ed3fbecb776acc5dcedcf81f3e">udd_enable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td></tr>
<tr class="separator:gad7f806ed3fbecb776acc5dcedcf81f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a97ab6519a34ae7d9135fe70c6719e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a97ab6519a34ae7d9135fe70c6719e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_resume_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSMEC_MASK)</td></tr>
<tr class="separator:ga8a97ab6519a34ae7d9135fe70c6719e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cad513921d4190558aa7744d672bfc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cad513921d4190558aa7744d672bfc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_resume_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSME_MASK))</td></tr>
<tr class="separator:ga3cad513921d4190558aa7744d672bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc25572243c4ab4600a1a870b4b6028b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc25572243c4ab4600a1a870b4b6028b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_resume</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSMC_MASK)</td></tr>
<tr class="separator:gabc25572243c4ab4600a1a870b4b6028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a47c6752a2cac56874691e34728ba5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32a47c6752a2cac56874691e34728ba5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_resume</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSMS_MASK)</td></tr>
<tr class="separator:ga32a47c6752a2cac56874691e34728ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2ed8acdccb1fa2d295610349979fe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b2ed8acdccb1fa2d295610349979fe5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_resume</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORSM_MASK))</td></tr>
<tr class="separator:ga1b2ed8acdccb1fa2d295610349979fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga1b192f6b945ae10b536deca002c2a1aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b192f6b945ae10b536deca002c2a1aa">udd_enable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td></tr>
<tr class="separator:ga1b192f6b945ae10b536deca002c2a1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac784d6d727d949449042d979d9a2ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeac784d6d727d949449042d979d9a2ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_wake_up_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_WAKEUPEC_MASK)</td></tr>
<tr class="separator:gaeac784d6d727d949449042d979d9a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab0126ceda728b5e100675a1368219a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeab0126ceda728b5e100675a1368219a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_wake_up_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_WAKEUPE_MASK))</td></tr>
<tr class="separator:gaeab0126ceda728b5e100675a1368219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf64e48ecbcfc8082ac438156d43311d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf64e48ecbcfc8082ac438156d43311d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_wake_up</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_WAKEUPC_MASK)</td></tr>
<tr class="separator:gadf64e48ecbcfc8082ac438156d43311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5a8ee09140c447b077c66c2e7668fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b5a8ee09140c447b077c66c2e7668fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_wake_up</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_WAKEUPS_MASK)</td></tr>
<tr class="separator:ga6b5a8ee09140c447b077c66c2e7668fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27099aac5c46e62ca82775e957ae52a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27099aac5c46e62ca82775e957ae52a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_wake_up</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_WAKEUP_MASK))</td></tr>
<tr class="separator:ga27099aac5c46e62ca82775e957ae52a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:gaa4f338d7c02eb47691d55ea26a0b32d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4f338d7c02eb47691d55ea26a0b32d7">udd_enable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td></tr>
<tr class="separator:gaa4f338d7c02eb47691d55ea26a0b32d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f19c394e2352deb16c13e15c34c59ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f19c394e2352deb16c13e15c34c59ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_reset_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSTEC_MASK)</td></tr>
<tr class="separator:ga4f19c394e2352deb16c13e15c34c59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0697533a9d3b806351a6a075100dd9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0697533a9d3b806351a6a075100dd9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_reset_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSTE_MASK))</td></tr>
<tr class="separator:gae0697533a9d3b806351a6a075100dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28a4338a4679d081090a536f7bd3ee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae28a4338a4679d081090a536f7bd3ee1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_reset</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSTC_MASK)</td></tr>
<tr class="separator:gae28a4338a4679d081090a536f7bd3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c25f895374748a59eaa9a84356a5d58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c25f895374748a59eaa9a84356a5d58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_reset</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSTS_MASK)</td></tr>
<tr class="separator:ga6c25f895374748a59eaa9a84356a5d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcb98dbb6f1255a0f25ae73035927db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bcb98dbb6f1255a0f25ae73035927db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_reset</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORST_MASK))</td></tr>
<tr class="separator:ga8bcb98dbb6f1255a0f25ae73035927db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga307066f7fb27b90020e50f7311b37ff6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga307066f7fb27b90020e50f7311b37ff6">udd_enable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td></tr>
<tr class="separator:ga307066f7fb27b90020e50f7311b37ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1210d31d31bcbcaf8374ac4db1521306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1210d31d31bcbcaf8374ac4db1521306"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_sof_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SOFEC_MASK)</td></tr>
<tr class="separator:ga1210d31d31bcbcaf8374ac4db1521306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc090cdf3bd05a4da6888695fd95786b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc090cdf3bd05a4da6888695fd95786b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_sof_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SOFE_MASK))</td></tr>
<tr class="separator:gacc090cdf3bd05a4da6888695fd95786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4140471f2e53d93cfe7f05ebd907d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b4140471f2e53d93cfe7f05ebd907d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_sof</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SOFC_MASK)</td></tr>
<tr class="separator:ga0b4140471f2e53d93cfe7f05ebd907d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3747765066014e9bbde1bb263334c8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3747765066014e9bbde1bb263334c8a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_sof</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SOFS_MASK)</td></tr>
<tr class="separator:ga3747765066014e9bbde1bb263334c8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5fcaa7cfa64de404ff9a3a257839a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b5fcaa7cfa64de404ff9a3a257839a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_sof</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SOF_MASK))</td></tr>
<tr class="separator:ga5b5fcaa7cfa64de404ff9a3a257839a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac175ccc890008605691939957098a246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac175ccc890008605691939957098a246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_frame_number</b>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNUM_MASK))</td></tr>
<tr class="separator:gac175ccc890008605691939957098a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f519fdc7583b259eb11d33555813182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f519fdc7583b259eb11d33555813182"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_frame_number_crc_error</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNCERR_MASK))</td></tr>
<tr class="separator:ga6f519fdc7583b259eb11d33555813182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga298cc43d16d7d9609d58adffe696b5db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga298cc43d16d7d9609d58adffe696b5db">udd_enable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td></tr>
<tr class="separator:ga298cc43d16d7d9609d58adffe696b5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1470fba0dbc68e890140d806277ee8c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1470fba0dbc68e890140d806277ee8c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_suspend_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SUSPEC_MASK)</td></tr>
<tr class="separator:ga1470fba0dbc68e890140d806277ee8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9c882005f263ea9e181273bf316e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a9c882005f263ea9e181273bf316e27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_suspend_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SUSPE_MASK))</td></tr>
<tr class="separator:ga2a9c882005f263ea9e181273bf316e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a61b0228571cf2c0225c86f3e3a618e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a61b0228571cf2c0225c86f3e3a618e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_suspend</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SUSPC_MASK)</td></tr>
<tr class="separator:ga9a61b0228571cf2c0225c86f3e3a618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997d9f1f31efd62ddcce775a4f40a0bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga997d9f1f31efd62ddcce775a4f40a0bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_suspend</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SUSPS_MASK)</td></tr>
<tr class="separator:ga997d9f1f31efd62ddcce775a4f40a0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9e8bbc2b3afefb19bcfd99db8b3fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfe9e8bbc2b3afefb19bcfd99db8b3fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_suspend</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SUSP_MASK))</td></tr>
<tr class="separator:gadfe9e8bbc2b3afefb19bcfd99db8b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC device address control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the USBC Device address. </p>
</div></td></tr>
<tr class="memitem:a45ad65d26b8b1c07d438d6a953356adc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45ad65d26b8b1c07d438d6a953356adc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a45ad65d26b8b1c07d438d6a953356adc">udd_enable_address</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr class="memdesc:a45ad65d26b8b1c07d438d6a953356adc"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables USB device address <br /></td></tr>
<tr class="separator:a45ad65d26b8b1c07d438d6a953356adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a5e9eb44ea5fd15eb4e9c7603e77c6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21a5e9eb44ea5fd15eb4e9c7603e77c6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21a5e9eb44ea5fd15eb4e9c7603e77c6">udd_disable_address</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr class="memdesc:a21a5e9eb44ea5fd15eb4e9c7603e77c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables USB device address <br /></td></tr>
<tr class="separator:a21a5e9eb44ea5fd15eb4e9c7603e77c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745c69fca49259a55f097b89be266d9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a745c69fca49259a55f097b89be266d9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_address_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_ADDEN_MASK))</td></tr>
<tr class="separator:a745c69fca49259a55f097b89be266d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6819ba3af1c84a7d7d33f059678e24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c6819ba3af1c84a7d7d33f059678e24"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5c6819ba3af1c84a7d7d33f059678e24">udd_configure_address</a>(addr)&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK, addr))</td></tr>
<tr class="memdesc:a5c6819ba3af1c84a7d7d33f059678e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the USB device address <br /></td></tr>
<tr class="separator:a5c6819ba3af1c84a7d7d33f059678e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf42f819560e7da3b51d0ab6b73c33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7abf42f819560e7da3b51d0ab6b73c33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7abf42f819560e7da3b51d0ab6b73c33">udd_get_configured_address</a>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udcon, AVR32_USBC_UDCON_UADD_MASK))</td></tr>
<tr class="memdesc:a7abf42f819560e7da3b51d0ab6b73c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the currently configured USB device address <br /></td></tr>
<tr class="separator:a7abf42f819560e7da3b51d0ab6b73c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device endpoint drivers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros manage the common features of the endpoints. </p>
</div></td></tr>
<tr class="memitem:a944621405e4cada2a5758a20c890cc73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(reg, index)&#160;&#160;&#160;((&amp;AVR32_USBC.reg)[(index)])</td></tr>
<tr class="separator:a944621405e4cada2a5758a20c890cc73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Devcice endpoint configguration</div></td></tr>
<tr class="memitem:ad03d0e3d03b41ad352bcfb1e20618cf3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad03d0e3d03b41ad352bcfb1e20618cf3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad03d0e3d03b41ad352bcfb1e20618cf3">udd_enable_endpoint</a>(ep)&#160;&#160;&#160;(Set_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:ad03d0e3d03b41ad352bcfb1e20618cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the selected endpoint <br /></td></tr>
<tr class="separator:ad03d0e3d03b41ad352bcfb1e20618cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78448032b7215b5c3168c2219609f439"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78448032b7215b5c3168c2219609f439"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a78448032b7215b5c3168c2219609f439">udd_disable_endpoint</a>(ep)&#160;&#160;&#160;(Clr_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:a78448032b7215b5c3168c2219609f439"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the selected endpoint <br /></td></tr>
<tr class="separator:a78448032b7215b5c3168c2219609f439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6904680ed0cc545a96efa2ca0d1a43"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6904680ed0cc545a96efa2ca0d1a43"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afe6904680ed0cc545a96efa2ca0d1a43">Is_udd_endpoint_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPEN0_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:afe6904680ed0cc545a96efa2ca0d1a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint is enabled <br /></td></tr>
<tr class="separator:afe6904680ed0cc545a96efa2ca0d1a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad104658f522a2947eac3ea93ec460ca9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad104658f522a2947eac3ea93ec460ca9">udd_reset_endpoint</a>(ep)</td></tr>
<tr class="memdesc:ad104658f522a2947eac3ea93ec460ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the selected endpoint  <a href="#ad104658f522a2947eac3ea93ec460ca9">More...</a><br /></td></tr>
<tr class="separator:ad104658f522a2947eac3ea93ec460ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bc67a85520896969c812e3002b565e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73bc67a85520896969c812e3002b565e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a73bc67a85520896969c812e3002b565e">Is_udd_resetting_endpoint</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:a73bc67a85520896969c812e3002b565e"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint is being reset <br /></td></tr>
<tr class="separator:a73bc67a85520896969c812e3002b565e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb296a52400f97a43b55679e95f0d1c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cb296a52400f97a43b55679e95f0d1c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a6cb296a52400f97a43b55679e95f0d1c">udd_configure_endpoint_type</a>(ep, type)&#160;&#160;&#160;(Wr_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK, type))</td></tr>
<tr class="memdesc:a6cb296a52400f97a43b55679e95f0d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint type <br /></td></tr>
<tr class="separator:a6cb296a52400f97a43b55679e95f0d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9038cc39fe44400c771b159f3ffe19e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9038cc39fe44400c771b159f3ffe19e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9038cc39fe44400c771b159f3ffe19e7">udd_get_endpoint_type</a>(ep)&#160;&#160;&#160;((Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK))&gt;&gt;AVR32_USBC_UECFG0_EPTYPE_OFFSET)</td></tr>
<tr class="memdesc:a9038cc39fe44400c771b159f3ffe19e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint type <br /></td></tr>
<tr class="separator:a9038cc39fe44400c771b159f3ffe19e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9bd49f7579a94166a10c4c6645f5de"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adf9bd49f7579a94166a10c4c6645f5de">udd_configure_endpoint_direction</a>(ep, dir)&#160;&#160;&#160;(Wr_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK, dir))</td></tr>
<tr class="memdesc:adf9bd49f7579a94166a10c4c6645f5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the bank autoswitch for the selected endpoint  <a href="#adf9bd49f7579a94166a10c4c6645f5de">More...</a><br /></td></tr>
<tr class="separator:adf9bd49f7579a94166a10c4c6645f5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9ebc6e500cfa654b2da58c235f1464"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e9ebc6e500cfa654b2da58c235f1464"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1e9ebc6e500cfa654b2da58c235f1464">udd_get_endpoint_direction</a>(ep)&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td></tr>
<tr class="memdesc:a1e9ebc6e500cfa654b2da58c235f1464"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint direction <br /></td></tr>
<tr class="separator:a1e9ebc6e500cfa654b2da58c235f1464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f80db7ea2439ef1fd11eaf0edceb91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f80db7ea2439ef1fd11eaf0edceb91"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_endpoint_in</b>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK))</td></tr>
<tr class="separator:ae9f80db7ea2439ef1fd11eaf0edceb91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc78147cab52be8b840973ef29d0076"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a>(size)&#160;&#160;&#160;(32 - clz(((uint32_t)min(max(size, 8), 1024) &lt;&lt; 1) - 1) - 1 - 3)</td></tr>
<tr class="separator:a9fc78147cab52be8b840973ef29d0076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed35d93ac28f5309919a8c6988baee47"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed35d93ac28f5309919a8c6988baee47"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aed35d93ac28f5309919a8c6988baee47">udd_configure_endpoint_size</a>(ep, size)&#160;&#160;&#160;(Wr_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK, <a class="el" href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a>(size)))</td></tr>
<tr class="memdesc:aed35d93ac28f5309919a8c6988baee47"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint size <br /></td></tr>
<tr class="separator:aed35d93ac28f5309919a8c6988baee47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16fa9454335f40118cc84efaa229c002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16fa9454335f40118cc84efaa229c002"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a16fa9454335f40118cc84efaa229c002">udd_get_endpoint_size</a>(ep)&#160;&#160;&#160;(8 &lt;&lt; Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPSIZE_MASK))</td></tr>
<tr class="memdesc:a16fa9454335f40118cc84efaa229c002"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint size <br /></td></tr>
<tr class="separator:a16fa9454335f40118cc84efaa229c002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5256fbd33ecb07fd5c1651f26d1b0313"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5256fbd33ecb07fd5c1651f26d1b0313"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5256fbd33ecb07fd5c1651f26d1b0313">udd_configure_endpoint_bank</a>(ep, bank)&#160;&#160;&#160;(Wr_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK, bank))</td></tr>
<tr class="memdesc:a5256fbd33ecb07fd5c1651f26d1b0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures the selected endpoint number of banks <br /></td></tr>
<tr class="separator:a5256fbd33ecb07fd5c1651f26d1b0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfae08b406c33eff07a328c0a1bf9f48"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfae08b406c33eff07a328c0a1bf9f48"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abfae08b406c33eff07a328c0a1bf9f48">udd_get_endpoint_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPBK_MASK))</td></tr>
<tr class="memdesc:abfae08b406c33eff07a328c0a1bf9f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets the configured selected endpoint number of banks <br /></td></tr>
<tr class="separator:abfae08b406c33eff07a328c0a1bf9f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0dd6d762bb7c07b3c085bfa77d7094a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab0dd6d762bb7c07b3c085bfa77d7094a">udd_configure_endpoint</a>(ep, type, dir, size, bank)</td></tr>
<tr class="memdesc:ab0dd6d762bb7c07b3c085bfa77d7094a"><td class="mdescLeft">&#160;</td><td class="mdescRight">configures selected endpoint in one step  <a href="#ab0dd6d762bb7c07b3c085bfa77d7094a">More...</a><br /></td></tr>
<tr class="separator:ab0dd6d762bb7c07b3c085bfa77d7094a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535c15be47ca7b41b9af4fcc01cdc71"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab535c15be47ca7b41b9af4fcc01cdc71"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab535c15be47ca7b41b9af4fcc01cdc71">udd_control_direction</a>()&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0(EP_CONTROL), AVR32_USBC_UESTA0_CTRLDIR_MASK))</td></tr>
<tr class="memdesc:ab535c15be47ca7b41b9af4fcc01cdc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the control direction <br /></td></tr>
<tr class="separator:ab535c15be47ca7b41b9af4fcc01cdc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8215756ce1ffa8c2ae43bd44cd1b5ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8215756ce1ffa8c2ae43bd44cd1b5ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af8215756ce1ffa8c2ae43bd44cd1b5ca">udd_reset_data_toggle</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_RSTDTS_MASK)</td></tr>
<tr class="memdesc:af8215756ce1ffa8c2ae43bd44cd1b5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets the data toggle sequence <br /></td></tr>
<tr class="separator:af8215756ce1ffa8c2ae43bd44cd1b5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6c06d0d3f8abf8cb14b4948782e6dd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee6c06d0d3f8abf8cb14b4948782e6dd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aee6c06d0d3f8abf8cb14b4948782e6dd">Is_udd_data_toggle_reset</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_RSTDT_MASK))</td></tr>
<tr class="memdesc:aee6c06d0d3f8abf8cb14b4948782e6dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the data toggle sequence is being reset <br /></td></tr>
<tr class="separator:aee6c06d0d3f8abf8cb14b4948782e6dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed983b720337e2ed5884d78e4519948"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abed983b720337e2ed5884d78e4519948"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abed983b720337e2ed5884d78e4519948">udd_data_toggle</a>(ep)&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_DTSEQ_MASK))</td></tr>
<tr class="memdesc:abed983b720337e2ed5884d78e4519948"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns data toggle <br /></td></tr>
<tr class="separator:abed983b720337e2ed5884d78e4519948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint interrupts</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoints interrupts. </p>
</div></td></tr>
<tr class="memitem:afeee27d730e49f7182fb7e1b40649947"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afeee27d730e49f7182fb7e1b40649947"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afeee27d730e49f7182fb7e1b40649947">udd_enable_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EP0INTES_MASK &lt;&lt; (ep))</td></tr>
<tr class="memdesc:afeee27d730e49f7182fb7e1b40649947"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the selected endpoint interrupt <br /></td></tr>
<tr class="separator:afeee27d730e49f7182fb7e1b40649947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b172bafee7421956c3d195b8c30da92"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b172bafee7421956c3d195b8c30da92"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a8b172bafee7421956c3d195b8c30da92">udd_disable_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EP0INTEC_MASK &lt;&lt; (ep))</td></tr>
<tr class="memdesc:a8b172bafee7421956c3d195b8c30da92"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the selected endpoint interrupt <br /></td></tr>
<tr class="separator:a8b172bafee7421956c3d195b8c30da92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b246cff0fb38d50d154b1e56dbd95fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b246cff0fb38d50d154b1e56dbd95fc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9b246cff0fb38d50d154b1e56dbd95fc">Is_udd_endpoint_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EP0INTE_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:a9b246cff0fb38d50d154b1e56dbd95fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if the selected endpoint interrupt is enabled <br /></td></tr>
<tr class="separator:a9b246cff0fb38d50d154b1e56dbd95fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12b636c365b3590aaab1685f5051e9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa12b636c365b3590aaab1685f5051e9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa12b636c365b3590aaab1685f5051e9d">Is_udd_endpoint_interrupt</a>(ep)&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EP0INT_MASK &lt;&lt; (ep)))</td></tr>
<tr class="memdesc:aa12b636c365b3590aaab1685f5051e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an interrupt is triggered by the selected endpoint <br /></td></tr>
<tr class="separator:aa12b636c365b3590aaab1685f5051e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626b75423f2c54799bbeaf2c1fc816f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a2626b75423f2c54799bbeaf2c1fc816f">udd_get_interrupt_endpoint_number</a>()</td></tr>
<tr class="memdesc:a2626b75423f2c54799bbeaf2c1fc816f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the lowest endpoint number generating an endpoint interrupt or MAX_PEP_NB if none  <a href="#a2626b75423f2c54799bbeaf2c1fc816f">More...</a><br /></td></tr>
<tr class="separator:a2626b75423f2c54799bbeaf2c1fc816f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint errors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint errors. </p>
</div></td></tr>
<tr class="memitem:a53559e240871eefce5727db759814f67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53559e240871eefce5727db759814f67"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a53559e240871eefce5727db759814f67">udd_enable_stall_handshake</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLRQS_MASK)</td></tr>
<tr class="memdesc:a53559e240871eefce5727db759814f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables the STALL handshake <br /></td></tr>
<tr class="separator:a53559e240871eefce5727db759814f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba0a5c25072f412af76337a9f78b49"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3ba0a5c25072f412af76337a9f78b49"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ab3ba0a5c25072f412af76337a9f78b49">udd_disable_stall_handshake</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLRQC_MASK)</td></tr>
<tr class="memdesc:ab3ba0a5c25072f412af76337a9f78b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables the STALL handshake <br /></td></tr>
<tr class="separator:ab3ba0a5c25072f412af76337a9f78b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00f503d09cc11156d7bcd275316fcc2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa00f503d09cc11156d7bcd275316fcc2"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa00f503d09cc11156d7bcd275316fcc2">Is_udd_endpoint_stall_requested</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_STALLRQ_MASK))</td></tr>
<tr class="memdesc:aa00f503d09cc11156d7bcd275316fcc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL handshake request is running <br /></td></tr>
<tr class="separator:aa00f503d09cc11156d7bcd275316fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f1423774570cc453649c43adffcde9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f1423774570cc453649c43adffcde9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa8f1423774570cc453649c43adffcde9">Is_udd_stall</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td></tr>
<tr class="memdesc:aa8f1423774570cc453649c43adffcde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL sent <br /></td></tr>
<tr class="separator:aa8f1423774570cc453649c43adffcde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80549eb8ff7c759ce3a0616ca2ff4e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a80549eb8ff7c759ce3a0616ca2ff4e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a80549eb8ff7c759ce3a0616ca2ff4e9a">udd_ack_stall</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td></tr>
<tr class="memdesc:a80549eb8ff7c759ce3a0616ca2ff4e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks STALL sent <br /></td></tr>
<tr class="separator:a80549eb8ff7c759ce3a0616ca2ff4e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2dcfdb7e62260eed0568dd4aae35e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18f2dcfdb7e62260eed0568dd4aae35e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a18f2dcfdb7e62260eed0568dd4aae35e">udd_raise_stall</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td></tr>
<tr class="memdesc:a18f2dcfdb7e62260eed0568dd4aae35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises STALL sent <br /></td></tr>
<tr class="separator:a18f2dcfdb7e62260eed0568dd4aae35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4273d7708a52f01c6c25ce1159d753"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d4273d7708a52f01c6c25ce1159d753"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5d4273d7708a52f01c6c25ce1159d753">udd_enable_stall_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td></tr>
<tr class="memdesc:a5d4273d7708a52f01c6c25ce1159d753"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables STALL sent interrupt <br /></td></tr>
<tr class="separator:a5d4273d7708a52f01c6c25ce1159d753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fec1c00b97a76215582b9245675a16f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fec1c00b97a76215582b9245675a16f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7fec1c00b97a76215582b9245675a16f">udd_disable_stall_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td></tr>
<tr class="memdesc:a7fec1c00b97a76215582b9245675a16f"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables STALL sent interrupt <br /></td></tr>
<tr class="separator:a7fec1c00b97a76215582b9245675a16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c29b9b3f54284bd7e2da8648e929c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a328c29b9b3f54284bd7e2da8648e929c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a328c29b9b3f54284bd7e2da8648e929c">Is_udd_stall_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td></tr>
<tr class="memdesc:a328c29b9b3f54284bd7e2da8648e929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if STALL sent interrupt is enabled <br /></td></tr>
<tr class="separator:a328c29b9b3f54284bd7e2da8648e929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9485a3763e6f605fbe0d699eb769e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a9485a3763e6f605fbe0d699eb769e0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7a9485a3763e6f605fbe0d699eb769e0">Is_udd_ram_access_error</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_RAMACCERI_MASK))</td></tr>
<tr class="memdesc:a7a9485a3763e6f605fbe0d699eb769e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if a RAM access error occur <br /></td></tr>
<tr class="separator:a7a9485a3763e6f605fbe0d699eb769e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa662342744f36999b1e7f7b427e421e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa662342744f36999b1e7f7b427e421e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa662342744f36999b1e7f7b427e421e6">Is_udd_nak_out</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_NAKOUTI_MASK))</td></tr>
<tr class="memdesc:aa662342744f36999b1e7f7b427e421e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK OUT received <br /></td></tr>
<tr class="separator:aa662342744f36999b1e7f7b427e421e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6aad5b3ec3f719a107a804c1c6157f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a6aad5b3ec3f719a107a804c1c6157f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9a6aad5b3ec3f719a107a804c1c6157f">udd_ack_nak_out</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKOUTIC_MASK)</td></tr>
<tr class="memdesc:a9a6aad5b3ec3f719a107a804c1c6157f"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks NAK OUT received <br /></td></tr>
<tr class="separator:a9a6aad5b3ec3f719a107a804c1c6157f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04078a2d8249cf03c22ffad483e3e7dc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04078a2d8249cf03c22ffad483e3e7dc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a04078a2d8249cf03c22ffad483e3e7dc">udd_raise_nak_out</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKOUTIS_MASK)</td></tr>
<tr class="memdesc:a04078a2d8249cf03c22ffad483e3e7dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises NAK OUT received <br /></td></tr>
<tr class="separator:a04078a2d8249cf03c22ffad483e3e7dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d46dfc6148b45b9505c33ed3133e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b4d46dfc6148b45b9505c33ed3133e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5b4d46dfc6148b45b9505c33ed3133e9">udd_enable_nak_out_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKOUTES_MASK)</td></tr>
<tr class="memdesc:a5b4d46dfc6148b45b9505c33ed3133e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables NAK OUT interrupt <br /></td></tr>
<tr class="separator:a5b4d46dfc6148b45b9505c33ed3133e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afebfb5c623a09ce5a760ac43ba54a583"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afebfb5c623a09ce5a760ac43ba54a583"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afebfb5c623a09ce5a760ac43ba54a583">udd_disable_nak_out_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKOUTEC_MASK)</td></tr>
<tr class="memdesc:afebfb5c623a09ce5a760ac43ba54a583"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables NAK OUT interrupt <br /></td></tr>
<tr class="separator:afebfb5c623a09ce5a760ac43ba54a583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa556fab3c46354bde3d2cdd02da700d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa556fab3c46354bde3d2cdd02da700d1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa556fab3c46354bde3d2cdd02da700d1">Is_udd_nak_out_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_NAKOUTE_MASK))</td></tr>
<tr class="memdesc:aa556fab3c46354bde3d2cdd02da700d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK OUT interrupt is enabled <br /></td></tr>
<tr class="separator:aa556fab3c46354bde3d2cdd02da700d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058bc49fc189ef865fe226cfcea4020b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a058bc49fc189ef865fe226cfcea4020b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a058bc49fc189ef865fe226cfcea4020b">Is_udd_nak_in</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_NAKINI_MASK))</td></tr>
<tr class="memdesc:a058bc49fc189ef865fe226cfcea4020b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK IN received <br /></td></tr>
<tr class="separator:a058bc49fc189ef865fe226cfcea4020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7ff845a31408640d21ab1abe2a3ac3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c7ff845a31408640d21ab1abe2a3ac3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9c7ff845a31408640d21ab1abe2a3ac3">udd_ack_nak_in</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_NAKINIC_MASK)</td></tr>
<tr class="memdesc:a9c7ff845a31408640d21ab1abe2a3ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks NAK IN received <br /></td></tr>
<tr class="separator:a9c7ff845a31408640d21ab1abe2a3ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add81f92998f841a45c0bbe3d4f13c6fa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add81f92998f841a45c0bbe3d4f13c6fa"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#add81f92998f841a45c0bbe3d4f13c6fa">udd_raise_nak_in</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_NAKINIS_MASK)</td></tr>
<tr class="memdesc:add81f92998f841a45c0bbe3d4f13c6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises NAK IN received <br /></td></tr>
<tr class="separator:add81f92998f841a45c0bbe3d4f13c6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc5e8ee2fe92c01b938b09d6cbee804"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbc5e8ee2fe92c01b938b09d6cbee804"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adbc5e8ee2fe92c01b938b09d6cbee804">udd_enable_nak_in_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_NAKINES_MASK)</td></tr>
<tr class="memdesc:adbc5e8ee2fe92c01b938b09d6cbee804"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables NAK IN interrupt <br /></td></tr>
<tr class="separator:adbc5e8ee2fe92c01b938b09d6cbee804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2beebb3753a3b3e86aaaf93cb8b958"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f2beebb3753a3b3e86aaaf93cb8b958"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1f2beebb3753a3b3e86aaaf93cb8b958">udd_disable_nak_in_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NAKINEC_MASK)</td></tr>
<tr class="memdesc:a1f2beebb3753a3b3e86aaaf93cb8b958"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables NAK IN interrupt <br /></td></tr>
<tr class="separator:a1f2beebb3753a3b3e86aaaf93cb8b958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d072c549f508c0bfa11877325ec6ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21d072c549f508c0bfa11877325ec6ca"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21d072c549f508c0bfa11877325ec6ca">Is_udd_nak_in_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_NAKINE_MASK))</td></tr>
<tr class="memdesc:a21d072c549f508c0bfa11877325ec6ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if NAK IN interrupt is enabled <br /></td></tr>
<tr class="separator:a21d072c549f508c0bfa11877325ec6ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a989c61a1ef03a3821e17a66a6ca47801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a989c61a1ef03a3821e17a66a6ca47801"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a989c61a1ef03a3821e17a66a6ca47801">udd_ack_overflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_OVERFIC_MASK)</td></tr>
<tr class="memdesc:a989c61a1ef03a3821e17a66a6ca47801"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks endpoint isochronous overflow interrupt <br /></td></tr>
<tr class="separator:a989c61a1ef03a3821e17a66a6ca47801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5a81edfbab51799c3a60c2a24e14c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5a81edfbab51799c3a60c2a24e14c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a1f5a81edfbab51799c3a60c2a24e14c8">udd_raise_overflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_OVERFIS_MASK)</td></tr>
<tr class="memdesc:a1f5a81edfbab51799c3a60c2a24e14c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises endpoint isochronous overflow interrupt <br /></td></tr>
<tr class="separator:a1f5a81edfbab51799c3a60c2a24e14c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a8109ed558b53a6c163ad4a1625ba1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19a8109ed558b53a6c163ad4a1625ba1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a19a8109ed558b53a6c163ad4a1625ba1">Is_udd_overflow</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_OVERFI_MASK))</td></tr>
<tr class="memdesc:a19a8109ed558b53a6c163ad4a1625ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an overflow occurs <br /></td></tr>
<tr class="separator:a19a8109ed558b53a6c163ad4a1625ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef25a39e90ff903696c0c6b0cf4b573"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ef25a39e90ff903696c0c6b0cf4b573"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7ef25a39e90ff903696c0c6b0cf4b573">udd_enable_overflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_OVERFES_MASK)</td></tr>
<tr class="memdesc:a7ef25a39e90ff903696c0c6b0cf4b573"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables overflow interrupt <br /></td></tr>
<tr class="separator:a7ef25a39e90ff903696c0c6b0cf4b573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae544aa935567496d6195ed4cd71ccc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaae544aa935567496d6195ed4cd71ccc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aaae544aa935567496d6195ed4cd71ccc">udd_disable_overflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_OVERFEC_MASK)</td></tr>
<tr class="memdesc:aaae544aa935567496d6195ed4cd71ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables overflow interrupt <br /></td></tr>
<tr class="separator:aaae544aa935567496d6195ed4cd71ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea027a8784874c6d9176c228d0bcfd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0eea027a8784874c6d9176c228d0bcfd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0eea027a8784874c6d9176c228d0bcfd">Is_udd_overflow_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_OVERFE_MASK))</td></tr>
<tr class="memdesc:a0eea027a8784874c6d9176c228d0bcfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if overflow interrupt is enabled <br /></td></tr>
<tr class="separator:a0eea027a8784874c6d9176c228d0bcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe43b87bdd82e175d8dd4a70022f77d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbe43b87bdd82e175d8dd4a70022f77d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#adbe43b87bdd82e175d8dd4a70022f77d">udd_ack_underflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_UNDERFIC_MASK)</td></tr>
<tr class="memdesc:adbe43b87bdd82e175d8dd4a70022f77d"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks endpoint isochronous underflow interrupt <br /></td></tr>
<tr class="separator:adbe43b87bdd82e175d8dd4a70022f77d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62a73b450f839afd0fa9373a20b6572"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac62a73b450f839afd0fa9373a20b6572"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac62a73b450f839afd0fa9373a20b6572">udd_raise_underflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_UNDERFIS_MASK)</td></tr>
<tr class="memdesc:ac62a73b450f839afd0fa9373a20b6572"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises endpoint isochronous underflow interrupt <br /></td></tr>
<tr class="separator:ac62a73b450f839afd0fa9373a20b6572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69cf9244b156e14a178ba1413f3efbc8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69cf9244b156e14a178ba1413f3efbc8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a69cf9244b156e14a178ba1413f3efbc8">Is_udd_underflow</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_UNDERFI_MASK))</td></tr>
<tr class="memdesc:a69cf9244b156e14a178ba1413f3efbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if an underflow occurs <br /></td></tr>
<tr class="separator:a69cf9244b156e14a178ba1413f3efbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6cd558da44828750e27cc78dba86e3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e6cd558da44828750e27cc78dba86e3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5e6cd558da44828750e27cc78dba86e3">udd_enable_underflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td></tr>
<tr class="memdesc:a5e6cd558da44828750e27cc78dba86e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables underflow interrupt <br /></td></tr>
<tr class="separator:a5e6cd558da44828750e27cc78dba86e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9414bf12df2ab83c146e18db3c185771"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9414bf12df2ab83c146e18db3c185771"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9414bf12df2ab83c146e18db3c185771">udd_disable_underflow_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td></tr>
<tr class="memdesc:a9414bf12df2ab83c146e18db3c185771"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables underflow interrupt <br /></td></tr>
<tr class="separator:a9414bf12df2ab83c146e18db3c185771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162bf1796a65a0165303957fd2430970"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a162bf1796a65a0165303957fd2430970"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a162bf1796a65a0165303957fd2430970">Is_udd_underflow_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td></tr>
<tr class="memdesc:a162bf1796a65a0165303957fd2430970"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if underflow interrupt is enabled <br /></td></tr>
<tr class="separator:a162bf1796a65a0165303957fd2430970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e25ea1e124ebe5ea9a6a9eb680b542"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6e25ea1e124ebe5ea9a6a9eb680b542"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad6e25ea1e124ebe5ea9a6a9eb680b542">Is_udd_crc_error</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_STALLEDI_MASK))</td></tr>
<tr class="memdesc:ad6e25ea1e124ebe5ea9a6a9eb680b542"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if CRC ERROR ISO OUT detected <br /></td></tr>
<tr class="separator:ad6e25ea1e124ebe5ea9a6a9eb680b542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73241164f2b850d0a7e5a76f013c1922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73241164f2b850d0a7e5a76f013c1922"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a73241164f2b850d0a7e5a76f013c1922">udd_ack_crc_error</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_STALLEDIC_MASK)</td></tr>
<tr class="memdesc:a73241164f2b850d0a7e5a76f013c1922"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks CRC ERROR ISO OUT detected <br /></td></tr>
<tr class="separator:a73241164f2b850d0a7e5a76f013c1922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c5d13c3b160178e0a1f18f50cc435b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a09c5d13c3b160178e0a1f18f50cc435b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a09c5d13c3b160178e0a1f18f50cc435b">udd_raise_crc_error</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_STALLEDIS_MASK)</td></tr>
<tr class="memdesc:a09c5d13c3b160178e0a1f18f50cc435b"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises CRC ERROR ISO OUT detected <br /></td></tr>
<tr class="separator:a09c5d13c3b160178e0a1f18f50cc435b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcf4430699577add8b0470749897371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4bcf4430699577add8b0470749897371"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4bcf4430699577add8b0470749897371">udd_enable_crc_error_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_STALLEDES_MASK)</td></tr>
<tr class="memdesc:a4bcf4430699577add8b0470749897371"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables CRC ERROR ISO OUT detected interrupt <br /></td></tr>
<tr class="separator:a4bcf4430699577add8b0470749897371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2a523826ed3ac39ffec2bf5e430d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a63e2a523826ed3ac39ffec2bf5e430d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a63e2a523826ed3ac39ffec2bf5e430d7">udd_disable_crc_error_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_STALLEDEC_MASK)</td></tr>
<tr class="memdesc:a63e2a523826ed3ac39ffec2bf5e430d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables CRC ERROR ISO OUT detected interrupt <br /></td></tr>
<tr class="separator:a63e2a523826ed3ac39ffec2bf5e430d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a42c1b5a4d7f8231ea015f5ce9e652c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a42c1b5a4d7f8231ea015f5ce9e652c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0a42c1b5a4d7f8231ea015f5ce9e652c">Is_udd_crc_error_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_STALLEDE_MASK))</td></tr>
<tr class="memdesc:a0a42c1b5a4d7f8231ea015f5ce9e652c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if CRC ERROR ISO OUT detected interrupt is enabled <br /></td></tr>
<tr class="separator:a0a42c1b5a4d7f8231ea015f5ce9e652c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint banks</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint banks. </p>
</div></td></tr>
<tr class="memitem:ac70a8020e42c03943b2e5cb247be6a27"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac70a8020e42c03943b2e5cb247be6a27">udd_ack_fifocon</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_FIFOCONC_MASK)</td></tr>
<tr class="memdesc:ac70a8020e42c03943b2e5cb247be6a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if endpoint read allowed  <a href="#ac70a8020e42c03943b2e5cb247be6a27">More...</a><br /></td></tr>
<tr class="separator:ac70a8020e42c03943b2e5cb247be6a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7eb71e23cbc004ff5e14d1b89ed5b5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b7eb71e23cbc004ff5e14d1b89ed5b5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9b7eb71e23cbc004ff5e14d1b89ed5b5">Is_udd_fifocon</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_FIFOCON_MASK))</td></tr>
<tr class="memdesc:a9b7eb71e23cbc004ff5e14d1b89ed5b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if FIFOCON bit set <br /></td></tr>
<tr class="separator:a9b7eb71e23cbc004ff5e14d1b89ed5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfa79f446bab64bee7ba639045cae3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aedfa79f446bab64bee7ba639045cae3f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aedfa79f446bab64bee7ba639045cae3f">udd_disable_nyet</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_NYETDISS_MASK)</td></tr>
<tr class="memdesc:aedfa79f446bab64bee7ba639045cae3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable NYET. <br /></td></tr>
<tr class="separator:aedfa79f446bab64bee7ba639045cae3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f3613c3c1aa1603c4c9f3e932be408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a19f3613c3c1aa1603c4c9f3e932be408"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a19f3613c3c1aa1603c4c9f3e932be408">udd_enable_nyet</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NYETDISC_MASK)</td></tr>
<tr class="memdesc:a19f3613c3c1aa1603c4c9f3e932be408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable NYET. <br /></td></tr>
<tr class="separator:a19f3613c3c1aa1603c4c9f3e932be408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7808ee92bc219ec6bc161749fd8d8848"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7808ee92bc219ec6bc161749fd8d8848"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a7808ee92bc219ec6bc161749fd8d8848">udd_enable_busy_bank0</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY0S_MASK)</td></tr>
<tr class="memdesc:a7808ee92bc219ec6bc161749fd8d8848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable busy on bank0. <br /></td></tr>
<tr class="separator:a7808ee92bc219ec6bc161749fd8d8848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00d2879deb19a5b70b0c1bf0cbabc2e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae00d2879deb19a5b70b0c1bf0cbabc2e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae00d2879deb19a5b70b0c1bf0cbabc2e">udd_disable_busy_bank0</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY0C_MASK)</td></tr>
<tr class="memdesc:ae00d2879deb19a5b70b0c1bf0cbabc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable busy on bank0. <br /></td></tr>
<tr class="separator:ae00d2879deb19a5b70b0c1bf0cbabc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f195135bbeaa0aceb54dada54387a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f195135bbeaa0aceb54dada54387a46"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a9f195135bbeaa0aceb54dada54387a46">udd_enable_busy_bank1</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_BUSY1S_MASK)</td></tr>
<tr class="memdesc:a9f195135bbeaa0aceb54dada54387a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable busy on bank1. <br /></td></tr>
<tr class="separator:a9f195135bbeaa0aceb54dada54387a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e41b2c169fc026153b7be55266b5966"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e41b2c169fc026153b7be55266b5966"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a0e41b2c169fc026153b7be55266b5966">udd_disable_busy_bank1</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_BUSY1C_MASK)</td></tr>
<tr class="memdesc:a0e41b2c169fc026153b7be55266b5966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable busy on bank1. <br /></td></tr>
<tr class="separator:a0e41b2c169fc026153b7be55266b5966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6d18d773abb7af0c1aa987006d7f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c6d18d773abb7af0c1aa987006d7f86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5c6d18d773abb7af0c1aa987006d7f86">udd_nb_busy_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_NBUSYBK_MASK))</td></tr>
<tr class="memdesc:a5c6d18d773abb7af0c1aa987006d7f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of busy banks <br /></td></tr>
<tr class="separator:a5c6d18d773abb7af0c1aa987006d7f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add031c6e7450e25a69b04416514d7696"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add031c6e7450e25a69b04416514d7696"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#add031c6e7450e25a69b04416514d7696">udd_current_bank</a>(ep)&#160;&#160;&#160;(Rd_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_CURRBK_MASK))</td></tr>
<tr class="memdesc:add031c6e7450e25a69b04416514d7696"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of the current bank <br /></td></tr>
<tr class="separator:add031c6e7450e25a69b04416514d7696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f6ff4bffcd208971419ac13427bc61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21f6ff4bffcd208971419ac13427bc61"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a21f6ff4bffcd208971419ac13427bc61">udd_kill_last_in_bank</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_KILLBKS_MASK)</td></tr>
<tr class="memdesc:a21f6ff4bffcd208971419ac13427bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">kills last bank <br /></td></tr>
<tr class="separator:a21f6ff4bffcd208971419ac13427bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de9e6f0520cb387d2db1bd71c91762b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4de9e6f0520cb387d2db1bd71c91762b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4de9e6f0520cb387d2db1bd71c91762b">Is_udd_last_in_bank_killed</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_KILLBK_MASK))</td></tr>
<tr class="memdesc:a4de9e6f0520cb387d2db1bd71c91762b"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if last bank killed <br /></td></tr>
<tr class="separator:a4de9e6f0520cb387d2db1bd71c91762b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b05771e325d90e9ff6497a84c35e62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a64b05771e325d90e9ff6497a84c35e62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a64b05771e325d90e9ff6497a84c35e62">udd_force_bank_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td></tr>
<tr class="memdesc:a64b05771e325d90e9ff6497a84c35e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">forces all banks full (OUT) or free (IN) interrupt <br /></td></tr>
<tr class="separator:a64b05771e325d90e9ff6497a84c35e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa522e5e1d2f1d10c0e594b45cf7b8497"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa522e5e1d2f1d10c0e594b45cf7b8497"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aa522e5e1d2f1d10c0e594b45cf7b8497">udd_unforce_bank_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_NBUSYBKS_MASK)</td></tr>
<tr class="memdesc:aa522e5e1d2f1d10c0e594b45cf7b8497"><td class="mdescLeft">&#160;</td><td class="mdescRight">unforces all banks full (OUT) or free (IN) interrupt <br /></td></tr>
<tr class="separator:aa522e5e1d2f1d10c0e594b45cf7b8497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdee8df03c3087459da437f64409de1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="affdee8df03c3087459da437f64409de1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#affdee8df03c3087459da437f64409de1">udd_enable_bank_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_NBUSYBKES_MASK)</td></tr>
<tr class="memdesc:affdee8df03c3087459da437f64409de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables all banks full (OUT) or free (IN) interrupt <br /></td></tr>
<tr class="separator:affdee8df03c3087459da437f64409de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b9ee869302039a5a8e97186579eaaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b9ee869302039a5a8e97186579eaaf"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af9b9ee869302039a5a8e97186579eaaf">udd_disable_bank_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_NBUSYBKEC_MASK)</td></tr>
<tr class="memdesc:af9b9ee869302039a5a8e97186579eaaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables all banks full (OUT) or free (IN) interrupt <br /></td></tr>
<tr class="separator:af9b9ee869302039a5a8e97186579eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6008ad2528d55b1830466e59e37ebc3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6008ad2528d55b1830466e59e37ebc3a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a6008ad2528d55b1830466e59e37ebc3a">Is_udd_bank_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_NBUSYBKE_MASK))</td></tr>
<tr class="memdesc:a6008ad2528d55b1830466e59e37ebc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if all banks full (OUT) or free (IN) interrupt enabled <br /></td></tr>
<tr class="separator:a6008ad2528d55b1830466e59e37ebc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329b1cde520fa81858ee360533d760c0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a329b1cde520fa81858ee360533d760c0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a329b1cde520fa81858ee360533d760c0">Is_udd_short_packet</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_SHORTPACKETI_MASK))</td></tr>
<tr class="memdesc:a329b1cde520fa81858ee360533d760c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SHORT PACKET received <br /></td></tr>
<tr class="separator:a329b1cde520fa81858ee360533d760c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583fd943c8a96f8561887cd996d6c05f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a583fd943c8a96f8561887cd996d6c05f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a583fd943c8a96f8561887cd996d6c05f">udd_ack_short_packet</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_SHORTPACKETIC_MASK)</td></tr>
<tr class="memdesc:a583fd943c8a96f8561887cd996d6c05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks SHORT PACKET received <br /></td></tr>
<tr class="separator:a583fd943c8a96f8561887cd996d6c05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac795af3e94f1202e6aab7b149632ab90"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac795af3e94f1202e6aab7b149632ab90"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ac795af3e94f1202e6aab7b149632ab90">udd_raise_short_packet</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_SHORTPACKETIS_MASK)</td></tr>
<tr class="memdesc:ac795af3e94f1202e6aab7b149632ab90"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises SHORT PACKET received <br /></td></tr>
<tr class="separator:ac795af3e94f1202e6aab7b149632ab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535f35b986fc195eb6a014cf9cfa8204"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a535f35b986fc195eb6a014cf9cfa8204"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a535f35b986fc195eb6a014cf9cfa8204">udd_enable_short_packet_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_SHORTPACKETES_MASK)</td></tr>
<tr class="memdesc:a535f35b986fc195eb6a014cf9cfa8204"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables SHORT PACKET received interrupt <br /></td></tr>
<tr class="separator:a535f35b986fc195eb6a014cf9cfa8204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5276a39a695e7fc7c72bd6dc68ba4d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d5276a39a695e7fc7c72bd6dc68ba4d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a5d5276a39a695e7fc7c72bd6dc68ba4d">udd_disable_short_packet_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_SHORTPACKETEC_MASK)</td></tr>
<tr class="memdesc:a5d5276a39a695e7fc7c72bd6dc68ba4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables SHORT PACKET received interrupt <br /></td></tr>
<tr class="separator:a5d5276a39a695e7fc7c72bd6dc68ba4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb8e430cbdb750273e87a48b7e544c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fb8e430cbdb750273e87a48b7e544c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4fb8e430cbdb750273e87a48b7e544c5">Is_udd_short_packet_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_SHORTPACKETE_MASK))</td></tr>
<tr class="memdesc:a4fb8e430cbdb750273e87a48b7e544c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SHORT PACKET received interrupt is enabled <br /></td></tr>
<tr class="separator:a4fb8e430cbdb750273e87a48b7e544c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USBC Device control endpoint transfer</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These macros control the endpoint transfers. </p>
</div></td></tr>
<tr class="memitem:a35421aaff45c60a7174d7082db2941f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35421aaff45c60a7174d7082db2941f4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a35421aaff45c60a7174d7082db2941f4">Is_udd_setup_received</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_RXSTPI_MASK))</td></tr>
<tr class="memdesc:a35421aaff45c60a7174d7082db2941f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SETUP received <br /></td></tr>
<tr class="separator:a35421aaff45c60a7174d7082db2941f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf07f0798c3538c4306af26f1eb9ce2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf07f0798c3538c4306af26f1eb9ce2b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#abf07f0798c3538c4306af26f1eb9ce2b">udd_ack_setup_received</a>(ep)&#160;&#160;&#160;((<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXSTPIC_MASK))</td></tr>
<tr class="memdesc:abf07f0798c3538c4306af26f1eb9ce2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks SETUP received <br /></td></tr>
<tr class="separator:abf07f0798c3538c4306af26f1eb9ce2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832e9941b31f7d7ba52cc0a2eb31e848"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a832e9941b31f7d7ba52cc0a2eb31e848"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a832e9941b31f7d7ba52cc0a2eb31e848">udd_raise_setup_received</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXSTPIS_MASK)</td></tr>
<tr class="memdesc:a832e9941b31f7d7ba52cc0a2eb31e848"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises SETUP received <br /></td></tr>
<tr class="separator:a832e9941b31f7d7ba52cc0a2eb31e848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50aa9e7b28504019f64a660d20d5160"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad50aa9e7b28504019f64a660d20d5160"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad50aa9e7b28504019f64a660d20d5160">udd_enable_setup_received_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_RXSTPES_MASK)</td></tr>
<tr class="memdesc:ad50aa9e7b28504019f64a660d20d5160"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables SETUP received interrupt <br /></td></tr>
<tr class="separator:ad50aa9e7b28504019f64a660d20d5160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668c58ec343f368da78ec9f15cae7373"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a668c58ec343f368da78ec9f15cae7373"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a668c58ec343f368da78ec9f15cae7373">udd_disable_setup_received_interrupt</a>()&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr(EP_CONTROL) = AVR32_USBC_UECON0CLR_RXSTPEC_MASK)</td></tr>
<tr class="memdesc:a668c58ec343f368da78ec9f15cae7373"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables SETUP received interrupt <br /></td></tr>
<tr class="separator:a668c58ec343f368da78ec9f15cae7373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4e77c5697efedbaa6ccef4f86dafcd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b4e77c5697efedbaa6ccef4f86dafcd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a4b4e77c5697efedbaa6ccef4f86dafcd">Is_udd_setup_received_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_RXSTPE_MASK))</td></tr>
<tr class="memdesc:a4b4e77c5697efedbaa6ccef4f86dafcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if SETUP received interrupt is enabled <br /></td></tr>
<tr class="separator:a4b4e77c5697efedbaa6ccef4f86dafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096c5fa1b85a21a8509f060f8dd6760c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a096c5fa1b85a21a8509f060f8dd6760c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a096c5fa1b85a21a8509f060f8dd6760c">Is_udd_out_received</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_RXOUTI_MASK))</td></tr>
<tr class="memdesc:a096c5fa1b85a21a8509f060f8dd6760c"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if OUT received <br /></td></tr>
<tr class="separator:a096c5fa1b85a21a8509f060f8dd6760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155aeea7bacc9d819976155da32ea20c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a155aeea7bacc9d819976155da32ea20c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a155aeea7bacc9d819976155da32ea20c">udd_ack_out_received</a>(ep)&#160;&#160;&#160;((<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_RXOUTIC_MASK))</td></tr>
<tr class="memdesc:a155aeea7bacc9d819976155da32ea20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks OUT received <br /></td></tr>
<tr class="separator:a155aeea7bacc9d819976155da32ea20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1844030b75833ccab407a93f23c5b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8aa1844030b75833ccab407a93f23c5b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a8aa1844030b75833ccab407a93f23c5b">udd_raise_out_received</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_RXOUTIS_MASK)</td></tr>
<tr class="memdesc:a8aa1844030b75833ccab407a93f23c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises OUT received <br /></td></tr>
<tr class="separator:a8aa1844030b75833ccab407a93f23c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d31f9be235d1f0b61a92914caec150"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2d31f9be235d1f0b61a92914caec150"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ad2d31f9be235d1f0b61a92914caec150">udd_enable_out_received_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_RXOUTES_MASK)</td></tr>
<tr class="memdesc:ad2d31f9be235d1f0b61a92914caec150"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables OUT received interrupt <br /></td></tr>
<tr class="separator:ad2d31f9be235d1f0b61a92914caec150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbef1c0e893909b48f08f369f5c2101e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acbef1c0e893909b48f08f369f5c2101e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#acbef1c0e893909b48f08f369f5c2101e">udd_disable_out_received_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_RXOUTEC_MASK)</td></tr>
<tr class="memdesc:acbef1c0e893909b48f08f369f5c2101e"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables OUT received interrupt <br /></td></tr>
<tr class="separator:acbef1c0e893909b48f08f369f5c2101e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91e68106149ba73e0e7a597d2f1f0e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af91e68106149ba73e0e7a597d2f1f0e7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#af91e68106149ba73e0e7a597d2f1f0e7">Is_udd_out_received_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_RXOUTE_MASK))</td></tr>
<tr class="memdesc:af91e68106149ba73e0e7a597d2f1f0e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if OUT received interrupt is enabled <br /></td></tr>
<tr class="separator:af91e68106149ba73e0e7a597d2f1f0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda1e279c304f18c0e96827e41da9d86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeda1e279c304f18c0e96827e41da9d86"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#aeda1e279c304f18c0e96827e41da9d86">Is_udd_in_send</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0,ep), AVR32_USBC_UESTA0_TXINI_MASK))</td></tr>
<tr class="memdesc:aeda1e279c304f18c0e96827e41da9d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if IN sending <br /></td></tr>
<tr class="separator:aeda1e279c304f18c0e96827e41da9d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eb4dd0bf6c6694f1dccb3677d4b243"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a11eb4dd0bf6c6694f1dccb3677d4b243"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a11eb4dd0bf6c6694f1dccb3677d4b243">udd_ack_in_send</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0clr,ep) = AVR32_USBC_UESTA0CLR_TXINIC_MASK)</td></tr>
<tr class="memdesc:a11eb4dd0bf6c6694f1dccb3677d4b243"><td class="mdescLeft">&#160;</td><td class="mdescRight">acks IN sending <br /></td></tr>
<tr class="separator:a11eb4dd0bf6c6694f1dccb3677d4b243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1d0b8c2a38cbbece773c60206982a3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb1d0b8c2a38cbbece773c60206982a3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#afb1d0b8c2a38cbbece773c60206982a3">udd_raise_in_send</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uesta0set,ep) = AVR32_USBC_UESTA0SET_TXINIS_MASK)</td></tr>
<tr class="memdesc:afb1d0b8c2a38cbbece773c60206982a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">raises IN sending <br /></td></tr>
<tr class="separator:afb1d0b8c2a38cbbece773c60206982a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93fcd4e4efec3740ac5e4f97bda5603"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93fcd4e4efec3740ac5e4f97bda5603"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae93fcd4e4efec3740ac5e4f97bda5603">udd_enable_in_send_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0set,ep) = AVR32_USBC_UECON0SET_TXINES_MASK)</td></tr>
<tr class="memdesc:ae93fcd4e4efec3740ac5e4f97bda5603"><td class="mdescLeft">&#160;</td><td class="mdescRight">enables IN sending interrupt <br /></td></tr>
<tr class="separator:ae93fcd4e4efec3740ac5e4f97bda5603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bc029dbdcb3e938af79d00cad2ada6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68bc029dbdcb3e938af79d00cad2ada6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#a68bc029dbdcb3e938af79d00cad2ada6">udd_disable_in_send_interrupt</a>(ep)&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_TXINEC_MASK)</td></tr>
<tr class="memdesc:a68bc029dbdcb3e938af79d00cad2ada6"><td class="mdescLeft">&#160;</td><td class="mdescRight">disables IN sending interrupt <br /></td></tr>
<tr class="separator:a68bc029dbdcb3e938af79d00cad2ada6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f86fc4a54e34216fd1defe06aca408"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4f86fc4a54e34216fd1defe06aca408"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="usbc__device_8h.html#ae4f86fc4a54e34216fd1defe06aca408">Is_udd_in_send_interrupt_enabled</a>(ep)&#160;&#160;&#160;(Tst_bits(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0,ep), AVR32_USBC_UECON0_TXINE_MASK))</td></tr>
<tr class="memdesc:ae4f86fc4a54e34216fd1defe06aca408"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests if IN sending interrupt is enabled <br /></td></tr>
<tr class="separator:ae4f86fc4a54e34216fd1defe06aca408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">USB Device endpoints descriptor table management</div></td></tr>
<tr class="memitem:a18bc2b2f31d1aa60873c324c03a2dd2a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18bc2b2f31d1aa60873c324c03a2dd2a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_set_buf0_addr</b>(ep, buf)&#160;&#160;&#160;udd_g_ep_table[ep*2].endpoint_pipe_address = buf</td></tr>
<tr class="separator:a18bc2b2f31d1aa60873c324c03a2dd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b918dae2ab647e3ca3139e3fa1bd835"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b918dae2ab647e3ca3139e3fa1bd835"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_rst_buf0_size</b>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = 0</td></tr>
<tr class="separator:a1b918dae2ab647e3ca3139e3fa1bd835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c540ab90d24659e8fb8646b6341c1d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c540ab90d24659e8fb8646b6341c1d4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_get_buf0_size</b>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size</td></tr>
<tr class="separator:a0c540ab90d24659e8fb8646b6341c1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3cec924aa661853b77c7bfa217f5f8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c3cec924aa661853b77c7bfa217f5f8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_set_buf0_size</b>(ep, size)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.multi_packet_size = size</td></tr>
<tr class="separator:a3c3cec924aa661853b77c7bfa217f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1c7b214972a5b48448d63174913a0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d1c7b214972a5b48448d63174913a0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_rst_buf0_ctn</b>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = 0</td></tr>
<tr class="separator:a3d1c7b214972a5b48448d63174913a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36dbb0f364c02ce1f3e8606063278824"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36dbb0f364c02ce1f3e8606063278824"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_get_buf0_ctn</b>(ep)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count</td></tr>
<tr class="separator:a36dbb0f364c02ce1f3e8606063278824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dbd2726ba58e81114c5a025548e479"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33dbd2726ba58e81114c5a025548e479"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_set_buf0_ctn</b>(ep, size)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.byte_count = size</td></tr>
<tr class="separator:a33dbd2726ba58e81114c5a025548e479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf40824e97da4c3c7cc651427bd2370c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf40824e97da4c3c7cc651427bd2370c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_udesc_set_buf0_autozlp</b>(ep, val)&#160;&#160;&#160;udd_g_ep_table[ep*2].SIZES.auto_zlp = val</td></tr>
<tr class="separator:adf40824e97da4c3c7cc651427bd2370c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add60165f4e021c5e08c9b647e65496c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="add60165f4e021c5e08c9b647e65496c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Usb_set_desc_tab_addr_reg</b>(addr)&#160;&#160;&#160;(Wr_bitfield(AVR32_USBC.udesc, AVR32_USBC_UDESC_MASK, addr))</td></tr>
<tr class="separator:add60165f4e021c5e08c9b647e65496c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>USBC Device Driver header file. </p>
<p>Copyright (C) 2009 Atmel Corporation. All rights reserved. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac70a8020e42c03943b2e5cb247be6a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_ack_fifocon</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecon0clr,ep) = AVR32_USBC_UECON0CLR_FIFOCONC_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>tests if endpoint read allowed </p>
<p>tests if endpoint write allowed clears FIFOCON bit </p>

</div>
</div>
<a class="anchor" id="ab0dd6d762bb7c07b3c085bfa77d7094a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dir, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bank&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(\</div>
<div class="line">   Wr_bits(<a class="code" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPTYPE_MASK |\</div>
<div class="line">                                  AVR32_USBC_UECFG0_EPDIR_MASK  |\</div>
<div class="line">                                  AVR32_USBC_UECFG0_EPSIZE_MASK |\</div>
<div class="line">                                  AVR32_USBC_UECFG0_EPBK_MASK,   \</div>
<div class="line">            (((uint32_t)(type) &lt;&lt; AVR32_USBC_UECFG0_EPTYPE_OFFSET) &amp; AVR32_USBC_UECFG0_EPTYPE_MASK) |\</div>
<div class="line">            (((uint32_t)(dir ) &lt;&lt; AVR32_USBC_UECFG0_EPDIR_OFFSET ) &amp; AVR32_USBC_UECFG0_EPDIR_MASK ) |\</div>
<div class="line">            ( (uint32_t)<a class="code" href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a>(size) &lt;&lt; AVR32_USBC_UECFG0_EPSIZE_OFFSET         ) |\</div>
<div class="line">            (((uint32_t)(bank) &lt;&lt; AVR32_USBC_UECFG0_EPBK_OFFSET  ) &amp; AVR32_USBC_UECFG0_EPBK_MASK  ))\</div>
<div class="line">)</div>
<div class="ttc" id="usbc__device_8h_html_a9fc78147cab52be8b840973ef29d0076"><div class="ttname"><a href="usbc__device_8h.html#a9fc78147cab52be8b840973ef29d0076">udd_format_endpoint_size</a></div><div class="ttdeci">#define udd_format_endpoint_size(size)</div><div class="ttdef"><b>Definition:</b> usbc_device.h:253</div></div>
<div class="ttc" id="usbc__device_8h_html_a944621405e4cada2a5758a20c890cc73"><div class="ttname"><a href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a></div><div class="ttdeci">#define USBC_ARRAY(reg, index)</div><div class="ttdef"><b>Definition:</b> usbc_device.h:219</div></div>
</div><!-- fragment -->
<p>configures selected endpoint in one step </p>

</div>
</div>
<a class="anchor" id="adf9bd49f7579a94166a10c4c6645f5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_configure_endpoint_direction</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dir&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(Wr_bitfield(<a class="el" href="usbc__device_8h.html#a944621405e4cada2a5758a20c890cc73">USBC_ARRAY</a>(uecfg0,ep), AVR32_USBC_UECFG0_EPDIR_MASK, dir))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enables the bank autoswitch for the selected endpoint </p>
<p>disables the bank autoswitch for the selected endpoint configures the selected endpoint direction </p>

</div>
</div>
<a class="anchor" id="a9fc78147cab52be8b840973ef29d0076"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_format_endpoint_size</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size</td><td>)</td>
          <td>&#160;&#160;&#160;(32 - clz(((uint32_t)min(max(size, 8), 1024) &lt;&lt; 1) - 1) - 1 - 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bounds given integer size to allowed range and rounds it up to the nearest available greater size, then applies register format of USBC controller for endpoint size bit-field. </p>

</div>
</div>
<a class="anchor" id="a2626b75423f2c54799bbeaf2c1fc816f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_get_interrupt_endpoint_number</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(ctz(((AVR32_USBC.udint &gt;&gt; AVR32_USBC_UDINT_EP0INT_OFFSET) &amp;\</div>
<div class="line">                                                   (AVR32_USBC.udinte &gt;&gt; AVR32_USBC_UDINTE_EP0INTE_OFFSET)) |\</div>
<div class="line">                                                   (1 &lt;&lt; MAX_PEP_NB)))</div>
</div><!-- fragment -->
<p>returns the lowest endpoint number generating an endpoint interrupt or MAX_PEP_NB if none </p>

</div>
</div>
<a class="anchor" id="ad104658f522a2947eac3ea93ec460ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_reset_endpoint</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ep</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(Set_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)),\</div>
<div class="line">                                                   Clr_bits(AVR32_USBC.uerst, AVR32_USBC_UERST_EPRST0_MASK &lt;&lt; (ep)))</div>
</div><!-- fragment -->
<p>resets the selected endpoint </p>

</div>
</div>
<a class="anchor" id="a944621405e4cada2a5758a20c890cc73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USBC_ARRAY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reg, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">index&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((&amp;AVR32_USBC.reg)[(index)])</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generic macro for USBC registers that can be arrayed </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 18 2014 14:18:46 for MAV&#39;RIC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
