<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>MAV&#39;RIC: USB Device Driver (UDD)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">MAV&#39;RIC
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#enumval-members">Enumerator</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">USB Device Driver (UDD)<div class="ingroups"><a class="el" href="group__usb__device__group.html">USB Stack Devices</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for USB Device Driver (UDD):</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__udd__group.png" border="0" alt="" usemap="#group____udd____group"/>
<map name="group____udd____group" id="group____udd____group">
<area shape="rect" id="node2" href="group__usb__device__group.html" title="USB Stack Devices" alt="" coords="5,5,145,32"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__setup__req__t.html">udd_setup_req_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information of the setup request management.  <a href="structudd__ctrl__request__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaffd9b7cf165cd149868373fa12595d12"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaffd9b7cf165cd149868373fa12595d12"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaffd9b7cf165cd149868373fa12595d12">Udd_setup_is_in</a>()&#160;&#160;&#160;(<a class="el" href="group__usb__protocol__group.html#ga3d3c24265f68a720887ae4ff7158d605">USB_REQ_DIR_IN</a> == (udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#gac94f5ec9106e17f2e6d927eeac3d530f">USB_REQ_DIR_MASK</a>))</td></tr>
<tr class="memdesc:gaffd9b7cf165cd149868373fa12595d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the setup request <em>udd_g_ctrlreq</em> indicates IN data transfer. <br /></td></tr>
<tr class="separator:gaffd9b7cf165cd149868373fa12595d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf67b7c8de30fdc881b567385f2345926"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf67b7c8de30fdc881b567385f2345926"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf67b7c8de30fdc881b567385f2345926">Udd_setup_is_out</a>()&#160;&#160;&#160;(<a class="el" href="group__usb__protocol__group.html#ga3fae7189eea003bf79ac2949b0f50584">USB_REQ_DIR_OUT</a> == (udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#gac94f5ec9106e17f2e6d927eeac3d530f">USB_REQ_DIR_MASK</a>))</td></tr>
<tr class="memdesc:gaf67b7c8de30fdc881b567385f2345926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the setup request <em>udd_g_ctrlreq</em> indicates OUT data transfer. <br /></td></tr>
<tr class="separator:gaf67b7c8de30fdc881b567385f2345926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85dc2b7b6c270e8dd8323fa4779a7ca2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga85dc2b7b6c270e8dd8323fa4779a7ca2">Udd_setup_type</a>()&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#ga8be8332e2da1e54c74c5f2a2230b0a28">USB_REQ_TYPE_MASK</a>)</td></tr>
<tr class="memdesc:ga85dc2b7b6c270e8dd8323fa4779a7ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the SETUP request <em>udd_g_ctrlreq</em>.  <a href="#ga85dc2b7b6c270e8dd8323fa4779a7ca2">More...</a><br /></td></tr>
<tr class="separator:ga85dc2b7b6c270e8dd8323fa4779a7ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac963bb7b8a965c2fec45a71c9faca6f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac963bb7b8a965c2fec45a71c9faca6f5">Udd_setup_recipient</a>()&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#gab1738c19d49fe1d4c7edccff90e9e9e4">USB_REQ_RECIP_MASK</a>)</td></tr>
<tr class="memdesc:gac963bb7b8a965c2fec45a71c9faca6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the recipient of the SETUP request <em>udd_g_ctrlreq</em>.  <a href="#gac963bb7b8a965c2fec45a71c9faca6f5">More...</a><br /></td></tr>
<tr class="separator:gac963bb7b8a965c2fec45a71c9faca6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6f25ea016c07bd48c3074f51d8ef8b01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f25ea016c07bd48c3074f51d8ef8b01"></a>
typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga6f25ea016c07bd48c3074f51d8ef8b01">udd_ep_id_t</a></td></tr>
<tr class="memdesc:ga6f25ea016c07bd48c3074f51d8ef8b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint identifier. <br /></td></tr>
<tr class="separator:ga6f25ea016c07bd48c3074f51d8ef8b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ab8d43f0761ecfb4d48770ac4ebb661"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7ab8d43f0761ecfb4d48770ac4ebb661"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7ab8d43f0761ecfb4d48770ac4ebb661">udd_callback_halt_cleared_t</a> )(void)</td></tr>
<tr class="memdesc:ga7ab8d43f0761ecfb4d48770ac4ebb661"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of halt callback function type. Registered by routine udd_ep_wait_stall_clear() Callback called when endpoint stall is cleared. <br /></td></tr>
<tr class="separator:ga7ab8d43f0761ecfb4d48770ac4ebb661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad866ed9444482edcf92a28dce807e3d3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad866ed9444482edcf92a28dce807e3d3">udd_callback_trans_t</a> )(<a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> status, iram_size_t nb_transfered)</td></tr>
<tr class="memdesc:gad866ed9444482edcf92a28dce807e3d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of transfer callback function type. Registered by routine udd_ep_run() Callback called by USB interrupt after data transfer or abort (reset,...).  <a href="#gad866ed9444482edcf92a28dce807e3d3">More...</a><br /></td></tr>
<tr class="separator:gad866ed9444482edcf92a28dce807e3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gac0f77f5a0e085af1242b48fd1054959a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac0f77f5a0e085af1242b48fd1054959a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> { <b>UDD_EP_TRANSFER_OK</b> = 0, 
<b>UDD_EP_TRANSFER_ABORT</b> = 1
 }</td></tr>
<tr class="memdesc:gac0f77f5a0e085af1242b48fd1054959a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint transfer status Returned in parameters of callback register via udd_ep_run routine. <br /></td></tr>
<tr class="separator:gac0f77f5a0e085af1242b48fd1054959a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga14096700b3ed8c5168615c5c5ee1c68d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga14096700b3ed8c5168615c5c5ee1c68d">COMPILER_PACK_SET</a> (1)</td></tr>
<tr class="memdesc:ga14096700b3ed8c5168615c5c5ee1c68d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A USB Device SETUP request.  <a href="#ga14096700b3ed8c5168615c5c5ee1c68d">More...</a><br /></td></tr>
<tr class="separator:ga14096700b3ed8c5168615c5c5ee1c68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe317a1520896eaf568afab27dc71540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabe317a1520896eaf568afab27dc71540"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>COMPILER_PACK_RESET</b> ()</td></tr>
<tr class="separator:gabe317a1520896eaf568afab27dc71540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga360872da67c7f8ecebe1238bbd4a536e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga360872da67c7f8ecebe1238bbd4a536e"></a>
<a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga360872da67c7f8ecebe1238bbd4a536e">udd_g_ctrlreq</a></td></tr>
<tr class="memdesc:ga360872da67c7f8ecebe1238bbd4a536e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information about setup request management. <br /></td></tr>
<tr class="separator:ga360872da67c7f8ecebe1238bbd4a536e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Power management routine.</h2></td></tr>
<tr class="memitem:gaf5ca2932775dabb853197df18706c469"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf5ca2932775dabb853197df18706c469"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf5ca2932775dabb853197df18706c469">USBC_SLEEP_MODE_USB_SUSPEND</a>&#160;&#160;&#160;<a class="el" href="group__sleepmgr__group.html#ggaa990bc3ea16fcad09009cdc70dbc38c6adbc00d523bb40feb59822bfbec8106c4">SLEEPMGR_STATIC</a></td></tr>
<tr class="memdesc:gaf5ca2932775dabb853197df18706c469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definition of sleep levels. <br /></td></tr>
<tr class="separator:gaf5ca2932775dabb853197df18706c469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90aeabbf00db4be8f0a1feef5cf0bbb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga90aeabbf00db4be8f0a1feef5cf0bbb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>USBC_SLEEP_MODE_USB_IDLE</b>&#160;&#160;&#160;<a class="el" href="group__sleepmgr__group.html#ggaa990bc3ea16fcad09009cdc70dbc38c6ae4f3742b3532d5ebabef6f26fabf4487">SLEEPMGR_IDLE</a></td></tr>
<tr class="separator:ga90aeabbf00db4be8f0a1feef5cf0bbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Control endpoint low level management routine.</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpc60f904f933dd5c177261b92bc2abc62"></a>This function performs control endpoint mangement. It handle the SETUP/DATA/HANDSHAKE phases of a control transaction. </p>
</td></tr>
<tr class="memitem:gabc925782d47feeb37f6f943579038b84"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">udd_ctrl_ep_state_t</a> { <br />
&#160;&#160;<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a2357a1ac77f59da70848f4121a016e77">UDD_EPCTRL_SETUP</a> = 0, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84acf3cc280a0061ecf321e0191d37dc53c">UDD_EPCTRL_DATA_OUT</a> = 1, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a57e63cb5de1f85c276dbfa8c3c00deed">UDD_EPCTRL_DATA_IN</a> = 2, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84aadbf4f42e07b8589262e727b3cf8b900">UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84ae5dd6cabf3ebb1aab6a80d7a92a89513">UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP</a> = 4, 
<a class="el" href="group__udd__group.html#ggabc925782d47feeb37f6f943579038b84a8d44562cd9ac18661adcf35015f8972e">UDD_EPCTRL_STALL_REQ</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:gabc925782d47feeb37f6f943579038b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit definitions about endpoint control state machine for udd_ep_control_state.  <a href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">More...</a><br /></td></tr>
<tr class="separator:gabc925782d47feeb37f6f943579038b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a41c2b14c5be825bdce7fde8c365a30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a41c2b14c5be825bdce7fde8c365a30"></a>
COMPILER_WORD_ALIGNED <br class="typebreak" />
<a class="el" href="structudd__ctrl__request__t.html">udd_ctrl_request_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga2a41c2b14c5be825bdce7fde8c365a30">udd_g_ctrlreq</a></td></tr>
<tr class="memdesc:ga2a41c2b14c5be825bdce7fde8c365a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global variable to give and record information about setup request management. <br /></td></tr>
<tr class="separator:ga2a41c2b14c5be825bdce7fde8c365a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Management of bulk/interrupt/isochronous endpoints</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpeb26be1d47656a473f2b25d5d9510dc8"></a>Buffer to store the data received on control endpoint (SETUP/OUT endpoint 0)</p>
<p>Used to avoid a RAM buffer overflow in case of the payload buffer is smaller than control endpoint size</p>
<p>The UDD manages the data transfer on endpoints:</p><ul>
<li>Start data tranfer on endpoint with USB Device DMA</li>
<li>Send a ZLP packet if requested</li>
<li>Call callback registered to signal end of transfer The transfer abort and stall feature are supported. </li>
</ul>
</td></tr>
<tr class="memitem:gaa4cac8c35ae056e26cf4ab5b426bbe09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4cac8c35ae056e26cf4ab5b426bbe09">udd_include_vbus_monitoring</a> (void)</td></tr>
<tr class="memdesc:gaa4cac8c35ae056e26cf4ab5b426bbe09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Authorizes the VBUS event.  <a href="#gaa4cac8c35ae056e26cf4ab5b426bbe09">More...</a><br /></td></tr>
<tr class="separator:gaa4cac8c35ae056e26cf4ab5b426bbe09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9792d1899ae058e3984d6a622fe2ad42"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9792d1899ae058e3984d6a622fe2ad42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga9792d1899ae058e3984d6a622fe2ad42">udd_enable</a> (void)</td></tr>
<tr class="memdesc:ga9792d1899ae058e3984d6a622fe2ad42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the USB Device mode. <br /></td></tr>
<tr class="separator:ga9792d1899ae058e3984d6a622fe2ad42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab283432057b934e9d73ac9282d9b0f11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab283432057b934e9d73ac9282d9b0f11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gab283432057b934e9d73ac9282d9b0f11">udd_disable</a> (void)</td></tr>
<tr class="memdesc:gab283432057b934e9d73ac9282d9b0f11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the USB Device mode. <br /></td></tr>
<tr class="separator:gab283432057b934e9d73ac9282d9b0f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7c0d9236c922c2af33c6702565a99f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga7a7c0d9236c922c2af33c6702565a99f">udd_attach</a> (void)</td></tr>
<tr class="memdesc:ga7a7c0d9236c922c2af33c6702565a99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach device to the bus when possible.  <a href="#ga7a7c0d9236c922c2af33c6702565a99f">More...</a><br /></td></tr>
<tr class="separator:ga7a7c0d9236c922c2af33c6702565a99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e59eaa264f1dbe5a52559311d0520e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga03e59eaa264f1dbe5a52559311d0520e">udd_detach</a> (void)</td></tr>
<tr class="memdesc:ga03e59eaa264f1dbe5a52559311d0520e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches the device from the bus.  <a href="#ga03e59eaa264f1dbe5a52559311d0520e">More...</a><br /></td></tr>
<tr class="separator:ga03e59eaa264f1dbe5a52559311d0520e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f403ddb78776b1ba014dafd3ffec2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga85f403ddb78776b1ba014dafd3ffec2c">udd_is_high_speed</a> (void)</td></tr>
<tr class="memdesc:ga85f403ddb78776b1ba014dafd3ffec2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the USB Device Controller is running at high speed or not.  <a href="#ga85f403ddb78776b1ba014dafd3ffec2c">More...</a><br /></td></tr>
<tr class="separator:ga85f403ddb78776b1ba014dafd3ffec2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05da762e0faf9d478e532de40afa71f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga05da762e0faf9d478e532de40afa71f6">udd_set_address</a> (uint8_t address)</td></tr>
<tr class="memdesc:ga05da762e0faf9d478e532de40afa71f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the USB address of device.  <a href="#ga05da762e0faf9d478e532de40afa71f6">More...</a><br /></td></tr>
<tr class="separator:ga05da762e0faf9d478e532de40afa71f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebd36638d482f6df00a8aff006ef2246"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaebd36638d482f6df00a8aff006ef2246">udd_getaddress</a> (void)</td></tr>
<tr class="memdesc:gaebd36638d482f6df00a8aff006ef2246"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the USB address of device.  <a href="#gaebd36638d482f6df00a8aff006ef2246">More...</a><br /></td></tr>
<tr class="separator:gaebd36638d482f6df00a8aff006ef2246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96dc248cc05e07ffe2cf21e4d7465320"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga96dc248cc05e07ffe2cf21e4d7465320">udd_get_frame_number</a> (void)</td></tr>
<tr class="memdesc:ga96dc248cc05e07ffe2cf21e4d7465320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current start of frame number.  <a href="#ga96dc248cc05e07ffe2cf21e4d7465320">More...</a><br /></td></tr>
<tr class="separator:ga96dc248cc05e07ffe2cf21e4d7465320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63047eec59b8e8798ca1d3366472d82b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga63047eec59b8e8798ca1d3366472d82b">udd_get_micro_frame_number</a> (void)</td></tr>
<tr class="memdesc:ga63047eec59b8e8798ca1d3366472d82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current micro start of frame number.  <a href="#ga63047eec59b8e8798ca1d3366472d82b">More...</a><br /></td></tr>
<tr class="separator:ga63047eec59b8e8798ca1d3366472d82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14ae6068206556d6ae8766b1baa2f686"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga14ae6068206556d6ae8766b1baa2f686"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga14ae6068206556d6ae8766b1baa2f686">udd_send_wake_up</a> (void)</td></tr>
<tr class="memdesc:ga14ae6068206556d6ae8766b1baa2f686"><td class="mdescLeft">&#160;</td><td class="mdescRight">The USB driver sends a resume signal called Upstream Resume. <br /></td></tr>
<tr class="separator:ga14ae6068206556d6ae8766b1baa2f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga017ef5ea7626be258c24d345218976f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga017ef5ea7626be258c24d345218976f9">udd_set_setup_payload</a> (uint8_t *payload, uint16_t payload_size)</td></tr>
<tr class="memdesc:ga017ef5ea7626be258c24d345218976f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load setup payload.  <a href="#ga017ef5ea7626be258c24d345218976f9">More...</a><br /></td></tr>
<tr class="separator:ga017ef5ea7626be258c24d345218976f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USBC Device IP properties</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp55d0406ba5e21eb26b437407f55e3f47"></a>These macros give access to IP properties </p>
</td></tr>
<tr class="memitem:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f3fc518ef0e369cc01a7bf7c6516844"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4f3fc518ef0e369cc01a7bf7c6516844">UDD_get_endpoint_max_nbr</a>()&#160;&#160;&#160;(((Rd_bitfield(AVR32_USBC_ufeatures, AVR32_USBC_UFEATURES_EPT_NBR_MAX_MASK) - 1) &amp; ((1 &lt;&lt; AVR32_USBC_UFEATURES_EPT_NBR_MAX_SIZE) - 1)) + 1)</td></tr>
<tr class="memdesc:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximal number of endpoints. <br /></td></tr>
<tr class="separator:ga4f3fc518ef0e369cc01a7bf7c6516844"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USBC Device speeds management</h2></td></tr>
<tr class="memitem:gaf272a0d4210ee260d0a267bba460fb0c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf272a0d4210ee260d0a267bba460fb0c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf272a0d4210ee260d0a267bba460fb0c">udd_low_speed_enable</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="memdesc:gaf272a0d4210ee260d0a267bba460fb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable device low-speed mode. <br /></td></tr>
<tr class="separator:gaf272a0d4210ee260d0a267bba460fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6471bbaea371bb9bb2654333236c9f29"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6471bbaea371bb9bb2654333236c9f29"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_low_speed_disable</b>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="separator:ga6471bbaea371bb9bb2654333236c9f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedea021600d07a71a1672b393c550c39"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaedea021600d07a71a1672b393c550c39"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaedea021600d07a71a1672b393c550c39">Is_udd_low_speed_enable</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_LS_MASK))</td></tr>
<tr class="memdesc:gaedea021600d07a71a1672b393c550c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if device low-speed mode is forced. <br /></td></tr>
<tr class="separator:gaedea021600d07a71a1672b393c550c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae014bb3adcdf212fd61196307be88802"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae014bb3adcdf212fd61196307be88802"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_high_speed_enable</b>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:gae014bb3adcdf212fd61196307be88802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7adf42a2ec72e7f2429a9b02799333af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga7adf42a2ec72e7f2429a9b02799333af"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_high_speed_disable</b>()&#160;&#160;&#160;do { } while (0)</td></tr>
<tr class="separator:ga7adf42a2ec72e7f2429a9b02799333af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga977c78f164f32fa910802518aab7b0ed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga977c78f164f32fa910802518aab7b0ed"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_full_speed_mode</b>()&#160;&#160;&#160;true</td></tr>
<tr class="separator:ga977c78f164f32fa910802518aab7b0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USBC Device vbus management</h2></td></tr>
<tr class="memitem:gaf80c5f873a9d926ab3324b6a91dfd872"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf80c5f873a9d926ab3324b6a91dfd872"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_enable_vbus_interrupt</b>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gaf80c5f873a9d926ab3324b6a91dfd872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad11887e29c08ad9cc6d67e3e6b4f9e9a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad11887e29c08ad9cc6d67e3e6b4f9e9a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_vbus_interrupt</b>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gad11887e29c08ad9cc6d67e3e6b4f9e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed8ac44b2b2082c1797e873e120867c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaed8ac44b2b2082c1797e873e120867c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbcon, AVR32_USBC_USBCON_VBUSTE_MASK))</td></tr>
<tr class="separator:gaed8ac44b2b2082c1797e873e120867c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bc6d84d73e1ecccae3318d4098c41a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga10bc6d84d73e1ecccae3318d4098c41a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_high</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUS_MASK))</td></tr>
<tr class="separator:ga10bc6d84d73e1ecccae3318d4098c41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f962d911e1863d143614d1ee01df89a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f962d911e1863d143614d1ee01df89a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_low</b>()&#160;&#160;&#160;(!Is_udd_vbus_high())</td></tr>
<tr class="separator:ga6f962d911e1863d143614d1ee01df89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6886b5956566ddb81744bbcfb27c08d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac6886b5956566ddb81744bbcfb27c08d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_vbus_transition</b>()&#160;&#160;&#160;(AVR32_USBC.usbstaclr = AVR32_USBC_USBSTACLR_VBUSTIC_MASK)</td></tr>
<tr class="separator:gac6886b5956566ddb81744bbcfb27c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8761342ea2dc32e0f0252508b1f7c47a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8761342ea2dc32e0f0252508b1f7c47a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_vbus_transition</b>()&#160;&#160;&#160;(AVR32_USBC.usbstaset = AVR32_USBC_USBSTASET_VBUSTIS_MASK)</td></tr>
<tr class="separator:ga8761342ea2dc32e0f0252508b1f7c47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb6dd005e6fef2574f054b8fe5e8d008"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gafb6dd005e6fef2574f054b8fe5e8d008"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_vbus_transition</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.usbsta, AVR32_USBC_USBSTA_VBUSTI_MASK))</td></tr>
<tr class="separator:gafb6dd005e6fef2574f054b8fe5e8d008"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USBC device attach control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp0e11470ac1c73a71585f2d1aea6db499"></a>These macros manage the USBC Device attach. </p>
</td></tr>
<tr class="memitem:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1863dacf593fb3c1b5f275b48f1e529a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1863dacf593fb3c1b5f275b48f1e529a">udd_detach_device</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="mdescLeft">&#160;</td><td class="mdescRight">detaches from USB bus <br /></td></tr>
<tr class="separator:ga1863dacf593fb3c1b5f275b48f1e529a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55686d13fc7b23f4945f527f0dd15906"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga55686d13fc7b23f4945f527f0dd15906"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga55686d13fc7b23f4945f527f0dd15906">udd_attach_device</a>()&#160;&#160;&#160;(Clr_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:ga55686d13fc7b23f4945f527f0dd15906"><td class="mdescLeft">&#160;</td><td class="mdescRight">attaches to USB bus <br /></td></tr>
<tr class="separator:ga55686d13fc7b23f4945f527f0dd15906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8c45e04066c136079dd296c2e28bb62"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf8c45e04066c136079dd296c2e28bb62"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaf8c45e04066c136079dd296c2e28bb62">Is_udd_detached</a>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_DETACH_MASK))</td></tr>
<tr class="memdesc:gaf8c45e04066c136079dd296c2e28bb62"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if the device is detached <br /></td></tr>
<tr class="separator:gaf8c45e04066c136079dd296c2e28bb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
USBC device bus events control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8685ab0e6929620c4e0d67ee25ea7fa9"></a>These macros manage the USBC Device bus events. </p>
</td></tr>
<tr class="memitem:gacc4b62140d09930dd38b10f766d30517"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gacc4b62140d09930dd38b10f766d30517">udd_initiate_remote_wake_up</a>()&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr class="separator:gacc4b62140d09930dd38b10f766d30517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3dab5078ad3286ac92d7b3a8cf8933a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaf3dab5078ad3286ac92d7b3a8cf8933a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_pending_remote_wake_up</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td></tr>
<tr class="separator:gaf3dab5078ad3286ac92d7b3a8cf8933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f538482266ca447cbfcfb9a5eb2bd64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga0f538482266ca447cbfcfb9a5eb2bd64">udd_enable_remote_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td></tr>
<tr class="separator:ga0f538482266ca447cbfcfb9a5eb2bd64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad53f9dce1280a2b17218090cde573368"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gad53f9dce1280a2b17218090cde573368"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_remote_wake_up_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_UPRSMEC_MASK)</td></tr>
<tr class="separator:gad53f9dce1280a2b17218090cde573368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a4c5935ae7ae26e8edf63a27d3d30d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a4c5935ae7ae26e8edf63a27d3d30d9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_remote_wake_up_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_UPRSME_MASK))</td></tr>
<tr class="separator:ga2a4c5935ae7ae26e8edf63a27d3d30d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39c4b005d3194988c8969ea622eed23d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga39c4b005d3194988c8969ea622eed23d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_remote_wake_up_start</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_UPRSMC_MASK)</td></tr>
<tr class="separator:ga39c4b005d3194988c8969ea622eed23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9d45e299d7a26b65bf8a98c8e27546"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e9d45e299d7a26b65bf8a98c8e27546"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_remote_wake_up_start</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_UPRSMS_MASK)</td></tr>
<tr class="separator:ga8e9d45e299d7a26b65bf8a98c8e27546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe73866ea62b418fe69fa061ef6edd3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacfe73866ea62b418fe69fa061ef6edd3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_remote_wake_up_start</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_UPRSM_MASK))</td></tr>
<tr class="separator:gacfe73866ea62b418fe69fa061ef6edd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f806ed3fbecb776acc5dcedcf81f3e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gad7f806ed3fbecb776acc5dcedcf81f3e">udd_enable_resume_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td></tr>
<tr class="separator:gad7f806ed3fbecb776acc5dcedcf81f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a97ab6519a34ae7d9135fe70c6719e4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8a97ab6519a34ae7d9135fe70c6719e4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_resume_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSMEC_MASK)</td></tr>
<tr class="separator:ga8a97ab6519a34ae7d9135fe70c6719e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cad513921d4190558aa7744d672bfc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3cad513921d4190558aa7744d672bfc3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_resume_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSME_MASK))</td></tr>
<tr class="separator:ga3cad513921d4190558aa7744d672bfc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc25572243c4ab4600a1a870b4b6028b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabc25572243c4ab4600a1a870b4b6028b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_resume</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSMC_MASK)</td></tr>
<tr class="separator:gabc25572243c4ab4600a1a870b4b6028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a47c6752a2cac56874691e34728ba5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga32a47c6752a2cac56874691e34728ba5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_resume</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSMS_MASK)</td></tr>
<tr class="separator:ga32a47c6752a2cac56874691e34728ba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b2ed8acdccb1fa2d295610349979fe5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1b2ed8acdccb1fa2d295610349979fe5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_resume</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORSM_MASK))</td></tr>
<tr class="separator:ga1b2ed8acdccb1fa2d295610349979fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b192f6b945ae10b536deca002c2a1aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga1b192f6b945ae10b536deca002c2a1aa">udd_enable_wake_up_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td></tr>
<tr class="separator:ga1b192f6b945ae10b536deca002c2a1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeac784d6d727d949449042d979d9a2ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeac784d6d727d949449042d979d9a2ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_wake_up_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_WAKEUPEC_MASK)</td></tr>
<tr class="separator:gaeac784d6d727d949449042d979d9a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab0126ceda728b5e100675a1368219a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaeab0126ceda728b5e100675a1368219a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_wake_up_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_WAKEUPE_MASK))</td></tr>
<tr class="separator:gaeab0126ceda728b5e100675a1368219a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf64e48ecbcfc8082ac438156d43311d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadf64e48ecbcfc8082ac438156d43311d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_wake_up</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_WAKEUPC_MASK)</td></tr>
<tr class="separator:gadf64e48ecbcfc8082ac438156d43311d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b5a8ee09140c447b077c66c2e7668fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6b5a8ee09140c447b077c66c2e7668fe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_wake_up</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_WAKEUPS_MASK)</td></tr>
<tr class="separator:ga6b5a8ee09140c447b077c66c2e7668fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27099aac5c46e62ca82775e957ae52a4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga27099aac5c46e62ca82775e957ae52a4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_wake_up</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_WAKEUP_MASK))</td></tr>
<tr class="separator:ga27099aac5c46e62ca82775e957ae52a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4f338d7c02eb47691d55ea26a0b32d7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#gaa4f338d7c02eb47691d55ea26a0b32d7">udd_enable_reset_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td></tr>
<tr class="separator:gaa4f338d7c02eb47691d55ea26a0b32d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f19c394e2352deb16c13e15c34c59ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga4f19c394e2352deb16c13e15c34c59ff"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_reset_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_EORSTEC_MASK)</td></tr>
<tr class="separator:ga4f19c394e2352deb16c13e15c34c59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0697533a9d3b806351a6a075100dd9f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae0697533a9d3b806351a6a075100dd9f"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_reset_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_EORSTE_MASK))</td></tr>
<tr class="separator:gae0697533a9d3b806351a6a075100dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28a4338a4679d081090a536f7bd3ee1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gae28a4338a4679d081090a536f7bd3ee1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_reset</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_EORSTC_MASK)</td></tr>
<tr class="separator:gae28a4338a4679d081090a536f7bd3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c25f895374748a59eaa9a84356a5d58"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6c25f895374748a59eaa9a84356a5d58"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_reset</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_EORSTS_MASK)</td></tr>
<tr class="separator:ga6c25f895374748a59eaa9a84356a5d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bcb98dbb6f1255a0f25ae73035927db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8bcb98dbb6f1255a0f25ae73035927db"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_reset</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_EORST_MASK))</td></tr>
<tr class="separator:ga8bcb98dbb6f1255a0f25ae73035927db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga307066f7fb27b90020e50f7311b37ff6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga307066f7fb27b90020e50f7311b37ff6">udd_enable_sof_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td></tr>
<tr class="separator:ga307066f7fb27b90020e50f7311b37ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1210d31d31bcbcaf8374ac4db1521306"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1210d31d31bcbcaf8374ac4db1521306"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_sof_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SOFEC_MASK)</td></tr>
<tr class="separator:ga1210d31d31bcbcaf8374ac4db1521306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc090cdf3bd05a4da6888695fd95786b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacc090cdf3bd05a4da6888695fd95786b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_sof_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SOFE_MASK))</td></tr>
<tr class="separator:gacc090cdf3bd05a4da6888695fd95786b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4140471f2e53d93cfe7f05ebd907d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b4140471f2e53d93cfe7f05ebd907d7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_sof</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SOFC_MASK)</td></tr>
<tr class="separator:ga0b4140471f2e53d93cfe7f05ebd907d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3747765066014e9bbde1bb263334c8a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga3747765066014e9bbde1bb263334c8a0"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_sof</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SOFS_MASK)</td></tr>
<tr class="separator:ga3747765066014e9bbde1bb263334c8a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b5fcaa7cfa64de404ff9a3a257839a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5b5fcaa7cfa64de404ff9a3a257839a9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_sof</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SOF_MASK))</td></tr>
<tr class="separator:ga5b5fcaa7cfa64de404ff9a3a257839a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac175ccc890008605691939957098a246"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac175ccc890008605691939957098a246"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_frame_number</b>()&#160;&#160;&#160;(Rd_bitfield(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNUM_MASK))</td></tr>
<tr class="separator:gac175ccc890008605691939957098a246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f519fdc7583b259eb11d33555813182"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga6f519fdc7583b259eb11d33555813182"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_frame_number_crc_error</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udfnum, AVR32_USBC_UDFNUM_FNCERR_MASK))</td></tr>
<tr class="separator:ga6f519fdc7583b259eb11d33555813182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga298cc43d16d7d9609d58adffe696b5db"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga298cc43d16d7d9609d58adffe696b5db">udd_enable_suspend_interrupt</a>()&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td></tr>
<tr class="separator:ga298cc43d16d7d9609d58adffe696b5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1470fba0dbc68e890140d806277ee8c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1470fba0dbc68e890140d806277ee8c1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_disable_suspend_interrupt</b>()&#160;&#160;&#160;(AVR32_USBC.udinteclr = AVR32_USBC_UDINTECLR_SUSPEC_MASK)</td></tr>
<tr class="separator:ga1470fba0dbc68e890140d806277ee8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9c882005f263ea9e181273bf316e27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2a9c882005f263ea9e181273bf316e27"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_suspend_interrupt_enabled</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udinte, AVR32_USBC_UDINTE_SUSPE_MASK))</td></tr>
<tr class="separator:ga2a9c882005f263ea9e181273bf316e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a61b0228571cf2c0225c86f3e3a618e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga9a61b0228571cf2c0225c86f3e3a618e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_ack_suspend</b>()&#160;&#160;&#160;(AVR32_USBC.udintclr = AVR32_USBC_UDINTCLR_SUSPC_MASK)</td></tr>
<tr class="separator:ga9a61b0228571cf2c0225c86f3e3a618e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997d9f1f31efd62ddcce775a4f40a0bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga997d9f1f31efd62ddcce775a4f40a0bd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>udd_raise_suspend</b>()&#160;&#160;&#160;(AVR32_USBC.udintset = AVR32_USBC_UDINTSET_SUSPS_MASK)</td></tr>
<tr class="separator:ga997d9f1f31efd62ddcce775a4f40a0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9e8bbc2b3afefb19bcfd99db8b3fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadfe9e8bbc2b3afefb19bcfd99db8b3fd"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>Is_udd_suspend</b>()&#160;&#160;&#160;(Tst_bits(AVR32_USBC.udint, AVR32_USBC_UDINT_SUSP_MASK))</td></tr>
<tr class="separator:gadfe9e8bbc2b3afefb19bcfd99db8b3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
High speed test mode management</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp2db3720a79ccf99f281dc8b84ab95b6b"></a>The following functions allow the device to jump to a specific test mode required in high speed mode. </p>
</td></tr>
<tr class="memitem:ga43ba1e91e69f84c1481a659ff8eff143"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga43ba1e91e69f84c1481a659ff8eff143"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>udd_test_mode_j</b> (void)</td></tr>
<tr class="separator:ga43ba1e91e69f84c1481a659ff8eff143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2acd547bcd2b470ee4e1ce34087926a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga2acd547bcd2b470ee4e1ce34087926a8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>udd_test_mode_k</b> (void)</td></tr>
<tr class="separator:ga2acd547bcd2b470ee4e1ce34087926a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabec7e8b6464e92ca9c8f32c59113bcbb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gabec7e8b6464e92ca9c8f32c59113bcbb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>udd_test_mode_se0_nak</b> (void)</td></tr>
<tr class="separator:gabec7e8b6464e92ca9c8f32c59113bcbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab72f68f8d1a50f7e734595a2ff626380"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab72f68f8d1a50f7e734595a2ff626380"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>udd_test_mode_packet</b> (void)</td></tr>
<tr class="separator:gab72f68f8d1a50f7e734595a2ff626380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
UDC callbacks to provide for UDD</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpac0b98f9d000f73c8d3a8c3cb0ebf40a"></a>The following callbacks are used by UDD. </p>
</td></tr>
<tr class="memitem:ga58c2916d7984e0e5b2143cadf4af6080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga58c2916d7984e0e5b2143cadf4af6080">udc_process_setup</a> (void)</td></tr>
<tr class="memdesc:ga58c2916d7984e0e5b2143cadf4af6080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes and manages a setup request.  <a href="#ga58c2916d7984e0e5b2143cadf4af6080">More...</a><br /></td></tr>
<tr class="separator:ga58c2916d7984e0e5b2143cadf4af6080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11a32ff7928ba06d3b59e95e0a2b7a92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga11a32ff7928ba06d3b59e95e0a2b7a92">udc_reset</a> (void)</td></tr>
<tr class="memdesc:ga11a32ff7928ba06d3b59e95e0a2b7a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the UDC.  <a href="#ga11a32ff7928ba06d3b59e95e0a2b7a92">More...</a><br /></td></tr>
<tr class="separator:ga11a32ff7928ba06d3b59e95e0a2b7a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4afae313045f44b5eb4c60957ab8ef4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__udd__group.html#ga4afae313045f44b5eb4c60957ab8ef4e">udc_sof_notify</a> (void)</td></tr>
<tr class="memdesc:ga4afae313045f44b5eb4c60957ab8ef4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To signal that a SOF is occured.  <a href="#ga4afae313045f44b5eb4c60957ab8ef4e">More...</a><br /></td></tr>
<tr class="separator:ga4afae313045f44b5eb4c60957ab8ef4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h1><a class="anchor" id="USBC_CONF"></a>
USBC Custom configuration</h1>
<p>The following USBC driver configuration must be included in the <a class="el" href="conf__usb_8h.html" title="USB configuration file for CDC application. ">conf_usb.h</a> file of the application.</p>
<p>UDD_USB_INT_LEVEL<br />
 Option to change the interrupt priority (0 to 3) by default 0 (recommended).</p>
<h1><a class="anchor" id="Callbacks"></a>
management</h1>
<p>The USB driver is fully managed by interrupt and does not request periodique task. Thereby, the USB events use callbacks to transfer the information. The callbacks are declared in static during compilation or in variable during code execution.</p>
<p>Static declarations defined in <a class="el" href="conf__usb_8h.html" title="USB configuration file for CDC application. ">conf_usb.h</a>:</p><ul>
<li><a class="el" href="conf__usb_8h.html#a009dfd7822890bfe9a8975f14d952508" title="USB Device string definitions (Optional) ">UDC_VBUS_EVENT(bool b_present)</a><br />
 To signal Vbus level change</li>
<li>UDC_SUSPEND_EVENT()<br />
 Called when USB bus enter in suspend mode</li>
<li>UDC_RESUME_EVENT()<br />
 Called when USB bus is wakeup</li>
<li>UDC_SOF_EVENT()<br />
 Called for each received SOF, Note: Each 1ms in HS/FS mode only.</li>
</ul>
<p>Dynamic callbacks, called "endpoint job" , are registered in udd_ep_job_t structure via the following functions:</p><ul>
<li>udd_ep_run()<br />
 To call it when a transfer is finish</li>
<li>udd_ep_wait_stall_clear()<br />
 To call it when a endpoint halt is disabled</li>
</ul>
<h1><a class="anchor" id="Power"></a>
mode management</h1>
<p>The Sleep modes authorized :</p><ul>
<li>in USB IDLE state, the USBC needs of USB clock and authorizes up to IDLE mode</li>
<li>in USB SUSPEND state, the USBC no needs USB clock but requests a minimum clock restart timing. Thus, it authorizes up to STATIC or STANDBY mode.</li>
<li>VBUS monitoring used in USB Self-Power mode authorizes up to STOP mode</li>
</ul>
<p>The USBC_SLEEP_MODE_USB_IDLE equals SLEEPMGR_IDLE.</p>
<p>The USBC_SLEEP_MODE_USB_SUSPEND depends on USB Power mode, USB clock startup timing and USB Speed mode: | Power Mode | Speed mode | Clock Startup | Sleep mode authorized | | X | LS, FS | &gt;10ms | SLEEPMGR_STDBY | | X | HS | &gt;3ms | SLEEPMGR_STDBY | | Self-Power | LS, FS | &lt;=10ms | SLEEPMGR_STOP | | Self-Power | HS | &lt;=3ms | SLEEPMGR_STOP | | Bus-Power | LS, FS | &lt;=10ms | SLEEPMGR_STATIC | | Bus-Power | HS | &lt;=3ms | SLEEPMGR_STATIC |</p>
<p>USBC low-level driver for USB Device mode</p>
<dl class="section warning"><dt>Warning</dt><dd>Bit-masks are used instead of bit-fields because PB registers require 32-bit write accesses while AVR32-GCC 4.0.2 builds 8-bit accesses even when volatile unsigned int bit-fields are specified.</dd></dl>
<p>The UDD driver provides a low-level abstraction of the device controller hardware. Most events coming from the hardware such as interrupts, which may cause the UDD to call into the UDC and UDI. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga0f538482266ca447cbfcfb9a5eb2bd64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_remote_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_UPRSMES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage upstream resume event (=remote wakeup) The USB driver sends a resume signal called "Upstream Resume" </p>

</div>
</div>
<a class="anchor" id="gaa4f338d7c02eb47691d55ea26a0b32d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_reset_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSTES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage reset event Set when a USB "End of Reset" has been detected </p>

</div>
</div>
<a class="anchor" id="gad7f806ed3fbecb776acc5dcedcf81f3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_resume_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_EORSMES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage end of resume event (=remote wakeup) The USB controller detects a valid "End of Resume" signal initiated by the host </p>

</div>
</div>
<a class="anchor" id="ga307066f7fb27b90020e50f7311b37ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_sof_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SOFES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage sart of frame event </p>

</div>
</div>
<a class="anchor" id="ga298cc43d16d7d9609d58adffe696b5db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_suspend_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_SUSPES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage suspend event </p>

</div>
</div>
<a class="anchor" id="ga1b192f6b945ae10b536deca002c2a1aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_enable_wake_up_interrupt</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(AVR32_USBC.udinteset = AVR32_USBC_UDINTESET_WAKEUPES_MASK)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manage wake-up event (=usb line activity) The USB controller is reactivated by a filtered non-idle signal from the lines </p>

</div>
</div>
<a class="anchor" id="gacc4b62140d09930dd38b10f766d30517"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define udd_initiate_remote_wake_up</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(Set_bits(AVR32_USBC.udcon, AVR32_USBC_UDCON_RMWKUP_MASK))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a remote wake-up event </p>

</div>
</div>
<a class="anchor" id="gac963bb7b8a965c2fec45a71c9faca6f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_recipient</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#gab1738c19d49fe1d4c7edccff90e9e9e4">USB_REQ_RECIP_MASK</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the recipient of the SETUP request <em>udd_g_ctrlreq</em>. </p>
<dl class="section see"><dt>See also</dt><dd>usb_recipient </dd></dl>

</div>
</div>
<a class="anchor" id="ga85dc2b7b6c270e8dd8323fa4779a7ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Udd_setup_type</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>&#160;&#160;&#160;(udd_g_ctrlreq.req.bmRequestType &amp; <a class="el" href="group__usb__protocol__group.html#ga8be8332e2da1e54c74c5f2a2230b0a28">USB_REQ_TYPE_MASK</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the SETUP request <em>udd_g_ctrlreq</em>. </p>
<dl class="section see"><dt>See also</dt><dd>usb_reqtype. </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad866ed9444482edcf92a28dce807e3d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* udd_callback_trans_t)(<a class="el" href="group__udd__group.html#gac0f77f5a0e085af1242b48fd1054959a">udd_ep_status_t</a> status, iram_size_t nb_transfered)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>End of transfer callback function type. Registered by routine udd_ep_run() Callback called by USB interrupt after data transfer or abort (reset,...). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>UDD_EP_TRANSFER_OK, if transfer is complete </td></tr>
    <tr><td class="paramname">status</td><td>UDD_EP_TRANSFER_ABORT, if transfer is aborted </td></tr>
    <tr><td class="paramname">n</td><td>number of data transfered </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gabc925782d47feeb37f6f943579038b84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__udd__group.html#gabc925782d47feeb37f6f943579038b84">udd_ctrl_ep_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bit definitions about endpoint control state machine for udd_ep_control_state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a2357a1ac77f59da70848f4121a016e77"></a>UDD_EPCTRL_SETUP&#160;</td><td class="fielddoc">
<p>Wait a SETUP packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84acf3cc280a0061ecf321e0191d37dc53c"></a>UDD_EPCTRL_DATA_OUT&#160;</td><td class="fielddoc">
<p>Wait a OUT data packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a57e63cb5de1f85c276dbfa8c3c00deed"></a>UDD_EPCTRL_DATA_IN&#160;</td><td class="fielddoc">
<p>Wait a IN data packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84aadbf4f42e07b8589262e727b3cf8b900"></a>UDD_EPCTRL_HANDSHAKE_WAIT_IN_ZLP&#160;</td><td class="fielddoc">
<p>Wait a IN ZLP packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84ae5dd6cabf3ebb1aab6a80d7a92a89513"></a>UDD_EPCTRL_HANDSHAKE_WAIT_OUT_ZLP&#160;</td><td class="fielddoc">
<p>Wait a OUT ZLP packet. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggabc925782d47feeb37f6f943579038b84a8d44562cd9ac18661adcf35015f8972e"></a>UDD_EPCTRL_STALL_REQ&#160;</td><td class="fielddoc">
<p>STALL enabled on IN &amp; OUT packet. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga14096700b3ed8c5168615c5c5ee1c68d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">COMPILER_PACK_SET </td>
          <td>(</td>
          <td class="paramtype">1&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A USB Device SETUP request. </p>
<p>SETUP packet contains following information. </p>

</div>
</div>
<a class="anchor" id="ga58c2916d7984e0e5b2143cadf4af6080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udc_process_setup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes and manages a setup request. </p>
<p>The driver call it when a SETUP packet is received. The <code>udd_g_ctrlreq</code> contains the data of SETUP packet. If this callback accepts the setup request then it must return <code>1</code> and eventually update <code>udd_g_ctrlreq</code> to send or receive data.</p>
<dl class="section return"><dt>Returns</dt><dd><code>1</code> if the request is accepted, otherwise <code>0</code>.</dd></dl>
<p>Decodes and manages a setup request.</p>
<p>This function parses a USB SETUP request and submits an appropriate response back to the host or, in the case of SETUP OUT requests with data, sets up a buffer for receiving the data payload.</p>
<p>The main standard requests defined by the USB 2.0 standard are handled internally. The interface requests are sent to UDI, and the specific request sent to a specific application callback.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the request is supported, else the request is stalled by UDD </dd></dl>

</div>
</div>
<a class="anchor" id="ga11a32ff7928ba06d3b59e95e0a2b7a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the UDC. </p>
<p>The UDC must reset all configuration.</p>
<p>Reset the UDC. </p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__udd__group_ga11a32ff7928ba06d3b59e95e0a2b7a92_icgraph.png" border="0" usemap="#group__udd__group_ga11a32ff7928ba06d3b59e95e0a2b7a92_icgraph" alt=""/></div>
<map name="group__udd__group_ga11a32ff7928ba06d3b59e95e0a2b7a92_icgraph" id="group__udd__group_ga11a32ff7928ba06d3b59e95e0a2b7a92_icgraph">
<area shape="rect" id="node2" href="group__udd__group.html#ga7a7c0d9236c922c2af33c6702565a99f" title="Attach device to the bus when possible. " alt="" coords="132,5,219,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga4afae313045f44b5eb4c60957ab8ef4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udc_sof_notify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To signal that a SOF is occured. </p>
<p>The UDC must send the signal to all UDIs enabled </p>

</div>
</div>
<a class="anchor" id="ga7a7c0d9236c922c2af33c6702565a99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_attach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach device to the bus when possible. </p>
<dl class="section warning"><dt>Warning</dt><dd>If a VBus control is included in driver, then it will attach device when an acceptable Vbus level from the host is detected. </dd></dl>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group__udd__group_ga7a7c0d9236c922c2af33c6702565a99f_cgraph.png" border="0" usemap="#group__udd__group_ga7a7c0d9236c922c2af33c6702565a99f_cgraph" alt=""/></div>
<map name="group__udd__group_ga7a7c0d9236c922c2af33c6702565a99f_cgraph" id="group__udd__group_ga7a7c0d9236c922c2af33c6702565a99f_cgraph">
<area shape="rect" id="node2" href="group__udc__group.html#ga11a32ff7928ba06d3b59e95e0a2b7a92" title="Reset the current configuration of the USB device, This routines can be called by UDD when a RESET on..." alt="" coords="140,5,219,32"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="ga03e59eaa264f1dbe5a52559311d0520e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_detach </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches the device from the bus. </p>
<p>The driver must remove pull-up on USB line D- or D+. </p>

</div>
</div>
<a class="anchor" id="ga96dc248cc05e07ffe2cf21e4d7465320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t udd_get_frame_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current start of frame number. </p>
<dl class="section return"><dt>Returns</dt><dd>current start of frame number. </dd></dl>

</div>
</div>
<a class="anchor" id="ga63047eec59b8e8798ca1d3366472d82b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t udd_get_micro_frame_number </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current micro start of frame number. </p>
<dl class="section return"><dt>Returns</dt><dd>current micro start of frame number required in high speed mode. </dd></dl>

</div>
</div>
<a class="anchor" id="gaebd36638d482f6df00a8aff006ef2246"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t udd_getaddress </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the USB address of device. </p>
<dl class="section return"><dt>Returns</dt><dd>USB address </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4cac8c35ae056e26cf4ab5b426bbe09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udd_include_vbus_monitoring </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Authorizes the VBUS event. </p>
<dl class="section return"><dt>Returns</dt><dd>true, if the VBUS monitoring is possible. </dd></dl>

</div>
</div>
<a class="anchor" id="ga85f403ddb78776b1ba014dafd3ffec2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool udd_is_high_speed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether the USB Device Controller is running at high speed or not. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the Device is running at high speed mode, otherwise <code>false</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga05da762e0faf9d478e532de40afa71f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_set_address </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the USB address of device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>New USB address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga017ef5ea7626be258c24d345218976f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void udd_set_setup_payload </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>payload_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load setup payload. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>Pointer on payload </td></tr>
    <tr><td class="paramname">payload_size</td><td>Size of payload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 18 2014 14:18:46 for MAV&#39;RIC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.7
</small></address>
</body>
</html>
